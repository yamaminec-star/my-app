<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" id="viewport-meta">
    <script>
        // URLパラメータからscaleを取得して表示倍率を設定
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const scaleParam = urlParams.get('scale');
            
            let appliedScale = 1.0;
            
            if (scaleParam) {
                // 数値に変換
                const scale = parseFloat(scaleParam);
                
                // 範囲チェック（0.1〜3.0に制限）
                const validScale = Math.max(0.1, Math.min(3.0, scale));
                
                // viewport metaタグを更新
                const viewport = document.getElementById('viewport-meta');
                if (viewport && !isNaN(validScale)) {
                    viewport.setAttribute('content', 
                        `width=device-width, initial-scale=${validScale}`);
                    appliedScale = validScale;
                }
            }
            
            // フィルターウィンドウのサイズを固定（Transform相殺）
            if (appliedScale !== 1.0) {
                window.addEventListener('DOMContentLoaded', function() {
                    const filterWindow = document.getElementById('frame-filters');
                    if (filterWindow) {
                        const inverseScale = 1 / appliedScale;
                        filterWindow.style.transform = `scale(${inverseScale})`;
                        filterWindow.style.transformOrigin = 'top left';
                        // 相殺後の幅を調整
                        filterWindow.style.width = `${100 * appliedScale}%`;
                    }
                });
            }
        })();
    </script>
    <title>micedraw-JUS4U-</title>
    <!-- Google Fonts Material Symbols -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'メイリオ', 'Meiryo', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            background: #f0f0f0;
        }

        /* シェブロンメニューバー */
        #menu-bar {
            background: #2c5f7c;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            align-items: stretch;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            position: relative;
            z-index: 100;
        }

        .chevron-button {
            position: relative;
            background: #2c5f7c;
            color: white;
            border: none;
            padding: 16px 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 15px;
            font-weight: bold;
            transition: all 0.3s ease;
            clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 50%, calc(100% - 15px) 100%, 0 100%, 15px 50%);
            margin-left: -15px;
            touch-action: manipulation;
        }

        .chevron-button:first-child {
            clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 50%, calc(100% - 15px) 100%, 0 100%);
            margin-left: 0;
        }

        .chevron-button.active {
            background: #e67e3c;
        }

        .chevron-button:hover:not(.active) {
            background: #3a7a9f;
        }

        .chevron-button .icon {
            font-family: 'Material Symbols Outlined';
            font-size: 28px;
            line-height: 1;
            font-weight: normal;
            font-style: normal;
            display: inline-block;
            white-space: nowrap;
            word-wrap: normal;
            direction: ltr;
            -webkit-font-smoothing: antialiased;
        }

        /* ハンバーガーメニュー */
        .menu-toggle {
            background: #2c5f7c;
            color: white;
            border: none;
            padding: 16px 25px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            font-size: 28px;
            touch-action: manipulation;
        }

        .menu-toggle .icon {
            font-family: 'Material Symbols Outlined';
            font-size: 32px;
        }

        .menu-toggle:hover {
            background: #3a7a9f;
        }

        /* 情報バー（PD + 製品名） */
        #info-bar {
            background: linear-gradient(90deg, #2c5f7c 200px, #4a7a95 200px);
            color: white;
            display: flex;
            align-items: center;
            padding: 12px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .pd-display {
            background: #1e4a5f;
            padding: 8px 20px;
            font-size: 24px;
            font-weight: bold;
            clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 50%, calc(100% - 15px) 100%, 0 100%);
            min-width: 180px;
        }

        .product-name {
            padding-left: 30px;
            font-size: 28px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        #main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .magnifier {
            position: fixed;
            width: 220px;
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 1000;
            display: none;
            top: 140px;
            left: calc(50% - 110px);
        }

        /* メニューバーが2列になった時の調整 */
        @media (max-width: 768px) {
            .magnifier {
                top: 180px;
            }
        }

        .magnifier.show {
            display: block;
        }

        .magnifier-header {
            background: #555;
            color: white;
            padding: 0;
            display: flex;
            align-items: stretch;
            cursor: move;
            user-select: none;
            border-bottom: 2px solid #666;
            min-height: 44px;
        }

        .magnifier-drag-bar {
            flex: 1;
            padding: 10px 12px;
            background: linear-gradient(180deg, #666 0%, #555 100%);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: move;
            user-select: none;
        }

        .magnifier-drag-bar:hover {
            background: linear-gradient(180deg, #777 0%, #666 100%);
        }

        .magnifier-title {
            flex: 1;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .magnifier-title .icon {
            font-size: 24px;
            font-family: 'Material Symbols Outlined';
        }

        .magnifier-body {
            width: 220px;
            height: 220px;
            position: relative;
            background: white;
        }

        #magnifier-canvas {
            width: 100%;
            height: 100%;
        }

        .magnifier-crosshair-v,
        .magnifier-crosshair-h {
            position: absolute;
            background-color: rgba(255, 0, 0, 0.6);
            pointer-events: none;
        }

        .magnifier-crosshair-v {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }

        .magnifier-crosshair-h {
            top: 50%;
            left: 0;
            height: 2px;
            width: 100%;
            transform: translateY(-50%);
        }

        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8f8f8;
            overflow: hidden;
            position: relative;
        }

        #main-canvas {
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
        }

        #status-bar {
            background-color: #f0f0f0;
            border-top: 1px solid #ccc;
            padding: 5px 10px;
            font-size: 12px;
        }

        /* フローティングカラーウィンドウ */
        .floating-window {
            position: fixed;
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 1000;
            display: none;
        }

        .floating-window.show {
            display: block;
        }

        #color-window {
            top: 140px;
            left: calc(50% - 182px);
            width: 364px; /* 520 * 0.7 */
            font-size: 12px;
        }
        
        #color-window .color-picker-area {
            height: 210px; /* 300 * 0.7 */
        }
        
        #color-window .rgba-display {
            padding: 8px;
            gap: 8px;
        }
        
        #color-window .rgba-label {
            font-size: 10px;
        }
        
        #color-window .rgba-value {
            font-size: 14px;
        }

        #info-window {
            top: 140px;
            left: calc(50% - 200px);
            width: 400px;
            max-height: 70vh;
        }
        
        #texture-window {
            top: 140px;
            left: calc(50% + 50px);
            width: 500px;
            max-height: 70vh;
        }
        
        #info-window.show {
            display: flex;
            flex-direction: column;
        }
        
        #info-window .window-body {
            overflow-y: auto;
            flex: 1;
        }

        .window-header {
            background: #555;
            color: white;
            padding: 0;
            display: flex;
            align-items: stretch;
            cursor: move;
            user-select: none;
            border-bottom: 2px solid #666;
            min-height: 44px;
            position: relative;
            z-index: 5;
        }

        .window-drag-bar {
            flex: 1;
            padding: 10px 16px;
            background: linear-gradient(180deg, #666 0%, #555 100%);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: move;
            user-select: none;
        }

        .window-drag-bar:hover {
            background: linear-gradient(180deg, #777 0%, #666 100%);
        }

        .window-title {
            flex: 1;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .window-title .icon {
            font-size: 24px;
            font-family: 'Material Symbols Outlined';
        }

        .close-btn {
            background: #c74440;
            border: none;
            color: white;
            cursor: pointer;
            width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            border-radius: 0;
            position: relative;
            z-index: 10;
        }
        
        .close-btn .icon {
            font-family: 'Material Symbols Outlined';
            font-size: 24px;
        }

        .close-btn:hover {
            background: #d55550;
        }

        .window-body {
            padding: 20px;
            background: #3a3a3a;
            color: white;
        }

        /* タブスタイル */
        .tab-header {
            display: flex;
            border-bottom: 2px solid #555;
        }

        .tab-button {
            flex: 1;
            background: #2a2a2a;
            color: #999;
            border: none;
            padding: 12px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            border-right: 1px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .tab-button:last-child {
            border-right: none;
        }

        .tab-button:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .tab-button.active {
            background: #4a4a4a;
            color: #fff;
        }

        .tab-button .icon {
            font-size: 24px;
            font-family: 'Material Symbols Outlined';
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 2Dカラーピッカー */
        .color-picker-area {
            width: 100%;
            height: 300px;
            position: relative;
            cursor: crosshair;
            border-radius: 8px;
            margin-bottom: 16px;
            background: linear-gradient(to bottom, transparent, black),
                        linear-gradient(to right, white, transparent);
        }

        .color-picker-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0,0,0,0.8);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        /* カラースライダー */
        .color-slider {
            margin-bottom: 16px;
        }

        .slider-track {
            width: 100%;
            height: 24px;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
        }

        .hue-track {
            background: linear-gradient(to right,
                rgb(255,0,0) 0%,
                rgb(255,255,0) 17%,
                rgb(0,255,0) 33%,
                rgb(0,255,255) 50%,
                rgb(0,0,255) 67%,
                rgb(255,0,255) 83%,
                rgb(255,0,0) 100%
            );
        }

        .opacity-track {
            background: linear-gradient(to right, transparent, white),
                        repeating-linear-gradient(45deg, #ccc 0px, #ccc 10px, #fff 10px, #fff 20px);
        }

        .slider-handle {
            position: absolute;
            top: 50%;
            width: 20px;
            height: 32px;
            background: white;
            border: 2px solid #333;
            border-radius: 4px;
            transform: translate(-50%, -50%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        /* RGBA表示 */
        .rgba-display {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: #2a2a2a;
            border-radius: 8px;
        }

        .rgba-item {
            flex: 1;
            text-align: center;
        }

        .rgba-label {
            font-size: 12px;
            color: #999;
            margin-bottom: 4px;
        }

        .rgba-value {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }

        /* パターンオプション */


        /* オーバーレイは使用しない */

        /* フレーム選択モーダル */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-window {
            background: #3a3a3a;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            width: 90vw;
            max-width: 1000px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            background: #555;
            color: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            border-bottom: 2px solid #666;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
        }

        .filter-toggle-btn {
            background: transparent;
            color: white;
            border: none;
            padding: 8px;
            margin-left: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s;
        }
        
        .filter-toggle-btn:hover {
            opacity: 0.7;
        }
        
        .filter-toggle-btn .icon {
            font-family: 'Material Symbols Outlined';
            font-size: 28px;
        }

                .modal-close-btn {
            background: #c74440;
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            margin-left: auto;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close-btn:hover {
            background: #d55550;
        }

        .modal-body {
            position: relative;
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .frame-filters {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 42, 42, 0.98);
            border: none;
            border-radius: 0;
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }
        
        .frame-filters.show {
            display: block;
        }

        .filter-group {
            margin-bottom: 20px;
        }

        .filter-group label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .range-row {
            display: flex;
            gap: 30px;
        }
        
        .range-item {
            flex: 1;
        }
        
        .range-item label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .range-slider-container {
            margin-top: 5px;
        }
        
        .range-slider {
            position: relative;
            height: 24px;
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .range-slider::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            height: 6px;
            background: #555;
            border-radius: 3px;
            pointer-events: none;
        }
        
        .range-slider input[type="range"] {
            position: absolute;
            width: 100%;
            height: 24px;
            background: transparent;
            pointer-events: none;
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
            padding: 0;
        }
        
        .range-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #999;
            cursor: pointer;
            pointer-events: auto;
            border: 3px solid #666;
            margin-top: 0;
        }
        
        .range-slider input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #999;
            cursor: pointer;
            pointer-events: auto;
            border: 3px solid #666;
        }
        
        .range-slider input[type="range"]::-webkit-slider-thumb:hover {
            background: #aaa;
        }
        
        .range-slider input[type="range"]::-moz-range-thumb:hover {
            background: #aaa;
        }
        
        .range-slider input[type="range"]::-webkit-slider-runnable-track {
            height: 24px;
            background: transparent;
        }
        
        .range-slider input[type="range"]::-moz-range-track {
            height: 24px;
            background: transparent;
            border: none;
        }
        
        .range-values {
            color: #ccc;
            font-size: 13px;
            text-align: center;
            font-family: monospace;
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .filter-buttons button {
            flex: 1;
            padding: 10px;
            background: #e67e3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        .filter-buttons button:hover {
            background: #d96d2c;
        }

        .filter-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .filter-checkboxes label {
            background: #4a4a4a;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: normal;
            margin: 0;
        }

        .filter-checkboxes input[type="checkbox"] {
            display: none;
        }

        .filter-checkboxes input[type="checkbox"]:checked + label {
            background: #e67e3c;
        }

        .frame-grid {
            flex: 1;
            width: 100%;
            padding: 20px;
            overflow-y: auto;
            display: grid;
            gap: 12px;
            background: #3a3a3a;
            justify-content: center;
            align-content: start;
        }

        .frame-item {
            background: #4a4a4a;
            border-radius: 8px;
            padding: 8px;
            height: 100px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .frame-item:hover {
            background: #5a5a5a;
            border-color: #e67e3c;
        }

        .frame-item img {
            object-fit: contain;
            background: white;
            border-radius: 4px;
        }

        .frame-item-name {
            color: white;
            font-size: 12px;
            margin-top: 6px;
            text-align: center;
        }

        .loading {
            color: #ccc;
            text-align: center;
            font-style: italic;
            grid-column: 1 / -1;
        }

        /* テクスチャウィンドウ専用スタイル */
        .texture-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            background: #3a3a3a;
            max-height: 400px;
            overflow-y: auto;
        }

        .texture-item {
            background: #4a4a4a;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .texture-item:hover {
            background: #5a5a5a;
            border-color: #e67e3c;
        }

        .texture-item.selected {
            border-color: #e67e3c;
            background: #5a5a5a;
        }

        .texture-preview {
            width: 100%;
            height: 60px;
            border-radius: 4px;
            background-size: cover;
            background-position: center;
            border: 1px solid #666;
        }

        .texture-item-name {
            color: white;
            font-size: 11px;
            margin-top: 6px;
            text-align: center;
            line-height: 1.2;
        }
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- シェブロンメニューバー -->
    <div id="menu-bar">
        <button class="chevron-button" id="open-face-btn" title="顔写真を開く">
            <span class="icon">face</span>
        </button>
        <button id="top-mode-button" class="chevron-button mode-measure" title="測定モード">
            <span class="icon">straighten</span>
        </button>
        <button class="chevron-button" id="open-frame-btn" title="フレーム選択">
            <span class="icon">eyeglasses</span>
        </button>
        <button class="chevron-button" id="texture-btn" title="テクスチャ選択">
            <span class="icon">texture</span>
        </button>
        <button class="chevron-button" id="color-window-btn" title="カラー設定">
            <span class="icon">palette</span>
        </button>
        <button class="chevron-button" id="reload-frame-btn" title="フレーム・テクスチャデータ更新">
            <span class="icon">refresh</span>
        </button>
        <button class="menu-toggle" id="info-window-btn" title="情報パネル">
            <span class="icon">menu</span>
        </button>
        <button class="menu-toggle" id="save-image-btn" title="画像を保存" style="margin-left: 0;">
            <span class="icon">save</span>
        </button>
    </div>

    <!-- 情報バー（PD + 製品名） -->
    <div id="info-bar">
        <div class="pd-display">
            PD: <input type="number" id="top-real-size" value="60" placeholder="60" 
                   style="width: 60px; padding: 4px 8px; border: 2px solid #fff; border-radius: 4px; font-size: 20px; font-weight: bold; text-align: center; background: rgba(255,255,255,0.2); color: white;">mm
        </div>
        <div class="product-name" id="product-name-display">製品名なし</div>
    </div>

    <!-- メインコンテナ -->
    <div id="main-container">
        <!-- キャンバスエリア -->
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
            <!-- 拡大鏡（フローティングウィンドウ形式） -->
            <div id="magnifier" class="magnifier">
                <div class="magnifier-header">
                    <div class="magnifier-drag-bar">
                        <div class="magnifier-title">
                            <span class="icon">zoom_in</span>
                        </div>
                    </div>
                </div>
                <div class="magnifier-body">
                    <canvas id="magnifier-canvas"></canvas>
                    <div class="magnifier-crosshair-v"></div>
                    <div class="magnifier-crosshair-h"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- フローティングカラーウィンドウ -->
    <div id="color-window" class="floating-window">
        <div class="window-header">
            <div class="window-drag-bar">
                <div class="window-title">
                    <span class="icon">palette</span>
                </div>
            </div>
            <button class="close-btn" id="color-window-close">
                <span class="icon">close</span>
            </button>
        </div>
        
        <div class="tab-header">
            <button class="tab-button active" id="tab-btn-black">
                <span class="icon">eyeglasses</span>
            </button>
            <button class="tab-button" id="tab-btn-white">
                <span class="icon">circle</span>
            </button>
        </div>

        <div class="window-body">
            <!-- 黒部分タブ -->
            <div class="tab-content active" id="tab-black">
                <div class="color-picker-area" id="black-picker">
                    <div class="color-picker-handle" id="black-handle"></div>
                </div>
                
                <div class="color-slider">
                    <div class="slider-track hue-track">
                        <div class="slider-handle" id="black-hue-handle"></div>
                    </div>
                </div>
                
                <div class="color-slider">
                    <div class="slider-track opacity-track">
                        <div class="slider-handle" id="black-opacity-handle"></div>
                    </div>
                </div>
                
                <div class="rgba-display">
                    <div class="rgba-item">
                        <div class="rgba-label">R</div>
                        <div class="rgba-value" id="black-r">0</div>
                    </div>
                    <div class="rgba-item">
                        <div class="rgba-label">G</div>
                        <div class="rgba-value" id="black-g">0</div>
                    </div>
                    <div class="rgba-item">
                        <div class="rgba-label">B</div>
                        <div class="rgba-value" id="black-b">0</div>
                    </div>
                    <div class="rgba-item">
                        <div class="rgba-label">A</div>
                        <div class="rgba-value" id="black-a">100</div>
                    </div>
                </div>
            </div>

            <!-- 白部分タブ -->
            <div class="tab-content" id="tab-white">
                <div class="color-picker-area" id="white-picker">
                    <div class="color-picker-handle" id="white-handle"></div>
                </div>
                
                <div class="color-slider">
                    <div class="slider-track hue-track">
                        <div class="slider-handle" id="white-hue-handle"></div>
                    </div>
                </div>
                
                <div class="color-slider">
                    <div class="slider-track opacity-track">
                        <div class="slider-handle" id="white-opacity-handle"></div>
                    </div>
                </div>
                
                <div class="rgba-display">
                    <div class="rgba-item">
                        <div class="rgba-label">R</div>
                        <div class="rgba-value" id="white-r">255</div>
                    </div>
                    <div class="rgba-item">
                        <div class="rgba-label">G</div>
                        <div class="rgba-value" id="white-g">255</div>
                    </div>
                    <div class="rgba-item">
                        <div class="rgba-label">B</div>
                        <div class="rgba-value" id="white-b">255</div>
                    </div>
                    <div class="rgba-item">
                        <div class="rgba-label">A</div>
                        <div class="rgba-value" id="white-a">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 情報ウィンドウ -->
    <div id="info-window" class="floating-window">
        <div class="window-header">
            <div class="window-drag-bar">
                <div class="window-title">
                    <span class="icon">info</span>
                </div>
            </div>
            <button class="close-btn" id="info-window-close">
                <span class="icon">close</span>
            </button>
        </div>
        <div class="window-body">
            <div id="info-window-content" style="color: #fff; font-size: 14px; line-height: 1.8;">
                <!-- 顔写真情報 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #ccc; border-bottom: 1px solid #555; padding-bottom: 4px;">顔写真情報</div>
                    <div style="padding-left: 12px;">
                        ? ファイル: <span id="face-file-name-window">未選択</span>
                    </div>
                </div>

                <!-- 比率計算 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #ccc; border-bottom: 1px solid #555; padding-bottom: 4px;">比率計算</div>
                    <div style="padding-left: 12px;">
                        ? 測定ピクセル: <span id="pixel-distance-window">--px</span><br>
                        ? 実際の距離: <span id="real-distance-window">60</span>mm<br>
                        ? 比率 (px/mm): <span id="scale-ratio-window">--</span>
                    </div>
                </div>

                <!-- フレーム情報 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #ccc; border-bottom: 1px solid #555; padding-bottom: 4px;">フレーム情報</div>
                    <div style="padding-left: 12px;">
                        ? ファイル: <span id="frame-file-name-window">未選択</span><br>
                        ? 実寸 (mm): <input type="number" id="frame-real-size-window" value="160" placeholder="160" style="width: 80px; padding: 4px 8px; margin-left: 4px; background: #2a2a2a; border: 1px solid #555; border-radius: 4px; color: white;">
                    </div>
                </div>

                <!-- カラー情報 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #ccc; border-bottom: 1px solid #555; padding-bottom: 4px;">カラー情報</div>
                    <div style="padding-left: 12px;">
                        ? 黒部分: <span id="color-black-window" style="font-family: monospace;">RGB(0, 0, 0) A:100</span><br>
                        ? 白部分: <span id="color-white-window" style="font-family: monospace;">RGB(255, 255, 255) A:0</span>
                    </div>
                </div>

                <!-- サイズ計算 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #ccc; border-bottom: 1px solid #555; padding-bottom: 4px;">サイズ計算</div>
                    <div style="padding-left: 12px;">
                        <div id="calc-160-window" style="color: #FF9800;">? 160mm: --px</div>
                    </div>
                </div>

                <!-- 測定情報 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #ccc; border-bottom: 1px solid #555; padding-bottom: 4px;">測定点</div>
                    <div id="measurement-points-window" style="padding-left: 12px;">
                        測定点なし
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- テクスチャ選択ウィンドウ -->
    <div id="texture-window" class="floating-window">
        <div class="window-header">
            <div class="window-drag-bar">
                <div class="window-title">
                    <span class="icon">texture</span>
                    テクスチャ選択
                </div>
            </div>
            <button class="close-btn" id="texture-window-close">
                <span class="icon">close</span>
            </button>
        </div>
        <div class="window-body">
            <div class="texture-grid" id="texture-grid">
                <div class="texture-item" onclick="app.selectTexture('none')">
                    <div class="texture-preview" style="background: #f0f0f0; color: #999; display: flex; align-items: center; justify-content: center;">カラー</div>
                    <div class="texture-item-name">カラー設定を使用</div>
                </div>
                <div class="loading">テクスチャ一覧を読み込み中...</div>
            </div>
        </div>
    </div>

    <!-- フレーム選択モーダル -->
    <div id="frame-selector-modal" class="modal-overlay" style="display: none;">
        <div class="modal-window">
            <div class="modal-header">
                <h3>フレーム選択</h3>
                <button class="filter-toggle-btn" id="filter-toggle-btn" onclick="app.toggleFrameFilter()">
                    <span class="icon">expand_more</span>
                </button>
                <button class="modal-close-btn" onclick="app.closeFrameSelector()">
                    <span class="icon">close</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="frame-filters" id="frame-filters">
                    <div class="filter-group">
                        <label>品名:</label>
                        <div class="filter-checkboxes" id="series-filters"></div>
                    </div>
                    <div class="filter-group">
                        <div class="range-row">
                            <div class="range-item">
                                <label>PD:</label>
                                <div class="range-slider-container">
                                    <div class="range-slider">
                                        <input type="range" id="pd-min" class="range-min" min="58" max="80" value="58" step="1">
                                        <input type="range" id="pd-max" class="range-max" min="58" max="80" value="80" step="1">
                                    </div>
                                    <div class="range-values" id="pd-values">58 - 80</div>
                                </div>
                            </div>
                            <div class="range-item">
                                <label>OW:</label>
                                <div class="range-slider-container">
                                    <div class="range-slider">
                                        <input type="range" id="ow-min" class="range-min" min="124" max="160" value="124" step="1">
                                        <input type="range" id="ow-max" class="range-max" min="124" max="160" value="160" step="1">
                                    </div>
                                    <div class="range-values" id="ow-values">124 - 160</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="filter-buttons">
                        <button onclick="app.clearFilterSelection()">選択のクリア</button>
                        <button onclick="app.updateFrameFilters()">適用</button>
                        <button onclick="app.toggleFrameFilter()">OK</button>
                    </div>
                </div>
                <div class="frame-grid" id="frame-grid">
                    <div class="loading">フレーム一覧を読み込み中...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ステータスバー -->
    <div id="status-bar">準備完了</div>

    <!-- 隠しファイル入力 -->
    <input type="file" id="face-input" accept="image/*" style="display:none" onchange="app.loadFaceImage(event)">
    <input type="file" id="frame-input" accept="image/*" style="display:none" onchange="app.loadFrameImage(event)">

    <script>
        class FaceMeasurementApp {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // 拡大鏡
                this.magnifier = document.getElementById('magnifier');
                this.magnifierCanvas = document.getElementById('magnifier-canvas');
                this.magnifierCtx = this.magnifierCanvas.getContext('2d');
                this.magnifierZoom = 3; // 3倍拡大
                
                // ファイル入力要素への参照
                this.faceInput = document.getElementById('face-input');
                this.frameInput = document.getElementById('frame-input');
                
                // 状態変数
                this.baseImage = null;
                this.frameImage = null;
                this.originalFrameImage = null;
                this.frameImageData = null;
                this.baseImageName = '';
                this.frameImageName = '';
                this.baseRealSize = 60; // 顔写真の実寸（初期値60mm）
                this.frameRealSize = 160;
                this.mode = 'measure'; // 'measure' or 'adjust'
                
                // フォルダパス
                this.faceFolder = '';
                this.frameFolder = '';
                this.lastFaceFile = '';
                this.lastFrameFile = '';
                
                // 測定関連
                this.measurementPoints = [];
                this.pixelDistance = 0;
                this.realDistance = 0;
                this.scaleRatio = 0;
                this.draggingPointIndex = -1;
                
                // フレーム位置
                this.frameOffset = {x: 100, y: 100};
                this.frameSize = {width: 0, height: 0};
                this.originalFrameSize = {width: 0, height: 0};
                this.dragging = false;
                this.dragStart = {x: 0, y: 0};
                
                // カラー設定
                this.hue = 0;
                this.saturation = 100;
                this.brightness = 0;
                this.opacity = 100; // 黒部分の透明度（初期値100 = 不透明）
                
                // サブカラー設定（白部分用）
                this.subHue = 0;
                this.subSaturation = 0;
                this.subBrightness = 0;
                this.subOpacity = 0;
                
                // 新UI用の状態
                this.colorWindowVisible = false;
                this.infoWindowVisible = false;
                this.currentColorTab = 'black';
                this.colorPickerDragging = false;
                this.hueSliderDragging = false;
                this.opacitySliderDragging = false;
                
                // フレーム選択関連
                this.availableFrames = [];
                this.filteredFrames = [];
                this.frameFilters = {
                    series: [],
                    pd: [],
                    ow: []
                };
                this.selectedFilters = {
                    series: [],
                    pd: [],
                    ow: []
                };
                this.filterVisible = false;
                this.pdRange = { min: 58, max: 80 };
                this.owRange = { min: 124, max: 160 };
                this.pdAvailableRange = { min: 58, max: 80 };
                this.owAvailableRange = { min: 124, max: 160 };
                
                // 物理ピクセル表示設定
                this.dpr = window.devicePixelRatio || 1;
                this.physicalImageWidth = 160;
                this.physicalImageHeight = 60;
                this.logicalImageWidth = this.physicalImageWidth / this.dpr;
                this.logicalImageHeight = this.physicalImageHeight / this.dpr;
                this.gridColumns = this.calculateGridColumns();
                
                // テクスチャ関連
                this.availableTextures = [];
                this.currentTexture = null;
                this.currentTextureName = 'none';
                
                // ウィンドウ位置保存
                this.windowPositions = {};
                
                // 初期化フラグ
                this.initialized = false;
                
                // 設定を読み込み
                this.loadSettings();
                
                // イベントリスナー設定
                this.setupEventListeners();
                
                // キャンバスサイズ設定
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // 初期ステータスバー更新
                this.updateStatusBar();
                
                // 初期モードボタンの状態を設定
                this.updateModeButton();
                
                // 初期顔画像を生成
                this.createInitialFaceImage();
            }

            // 初期顔画像を生成
            createInitialFaceImage() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 2000;
                tempCanvas.height = 2000;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 白背景
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, 2000, 2000);
                
                // テキスト設定
                tempCtx.fillStyle = 'gray';
                tempCtx.font = '300px "Franklin Gothic", "Arial Narrow", sans-serif';
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                
                // テキスト描画
                tempCtx.fillText('JUS4U', 1000, 1000);
                
                // Imageオブジェクトに変換
                const img = new Image();
                img.onload = () => {
                    this.baseImage = img;
                    this.baseImageName = 'JUS4U (初期画像)';
                    this.redraw();
                    this.updateStatusBar();
                    this.updateInfoWindowContent();
                };
                img.src = tempCanvas.toDataURL();
            }

            loadSettings() {
                try {
                    const settings = localStorage.getItem('faceMeasurementSettings');
                    if (settings) {
                        const data = JSON.parse(settings);
                        
                        // フォルダパス
                        if (data.faceFolder) this.faceFolder = data.faceFolder;
                        if (data.frameFolder) this.frameFolder = data.frameFolder;
                        if (data.lastFaceFile) this.lastFaceFile = data.lastFaceFile;
                        if (data.lastFrameFile) this.lastFrameFile = data.lastFrameFile;
                        
                        // 実寸値
                        if (data.baseRealSize !== undefined) this.baseRealSize = data.baseRealSize;
                        if (data.frameRealSize !== undefined) this.frameRealSize = data.frameRealSize;
                        
                        // カラー設定
                        if (data.hue !== undefined) this.hue = data.hue;
                        if (data.saturation !== undefined) this.saturation = data.saturation;
                        if (data.brightness !== undefined) this.brightness = data.brightness;
                        if (data.opacity !== undefined) this.opacity = data.opacity;
                        
                        // サブカラー設定
                        if (data.subHue !== undefined) this.subHue = data.subHue;
                        if (data.subSaturation !== undefined) this.subSaturation = data.subSaturation;
                        if (data.subBrightness !== undefined) this.subBrightness = data.subBrightness;
                        if (data.subOpacity !== undefined) this.subOpacity = data.subOpacity;
                        
                        // ウィンドウ位置
                        if (data.windowPositions) this.windowPositions = data.windowPositions;
                        
                        // テクスチャ設定
                        if (data.currentTextureName) this.currentTextureName = data.currentTextureName;
                        
                        // UIに反映（アプリ初期化時のみ）
                        if (!this.initialized) {
                            setTimeout(() => {
                                this.applySettingsToUI();
                                this.restoreWindowPositions();
                                this.initialized = true;
                            }, 100);
                        } else {
                            // 初期化済みの場合はUIのみ更新
                            this.applySettingsToUI();
                        }
                    }
                } catch (e) {
                    console.error('設定の読み込みに失敗:', e);
                }
            }

            saveSettings() {
                try {
                    const settings = {
                        faceFolder: this.faceFolder,
                        frameFolder: this.frameFolder,
                        lastFaceFile: this.lastFaceFile,
                        lastFrameFile: this.lastFrameFile,
                        baseRealSize: this.baseRealSize,
                        frameRealSize: this.frameRealSize,
                        hue: this.hue,
                        saturation: this.saturation,
                        brightness: this.brightness,
                        opacity: this.opacity,
                        subHue: this.subHue,
                        subSaturation: this.subSaturation,
                        subBrightness: this.subBrightness,
                        subOpacity: this.subOpacity,
                        windowPositions: this.windowPositions,
                        currentTextureName: this.currentTextureName
                    };
                    
                    localStorage.setItem('faceMeasurementSettings', JSON.stringify(settings));
                } catch (e) {
                    console.error('設定の保存に失敗:', e);
                }
            }

            applySettingsToUI() {
                // PD値
                const topRealSizeEl = document.getElementById('top-real-size');
                if (topRealSizeEl) topRealSizeEl.value = this.baseRealSize;
                
                // フレーム実寸
                const frameRealSizeWindowEl = document.getElementById('frame-real-size-window');
                if (frameRealSizeWindowEl) frameRealSizeWindowEl.value = this.frameRealSize;
            }

            setupEventListeners() {
                // マウスイベント
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => {
                    this.onMouseMove(e);
                    if (this.mode === 'measure' && this.baseImage) {
                        this.updateMagnifier(e.clientX, e.clientY);
                    }
                });
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // タッチイベント
                this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), {passive: false});
                this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), {passive: false});
                this.canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), {passive: false});
                
                // メニューバーボタン
                const openFaceBtn = document.getElementById('open-face-btn');
                if (openFaceBtn) openFaceBtn.addEventListener('click', () => this.openFaceImage());
                
                const topModeBtn = document.getElementById('top-mode-button');
                if (topModeBtn) topModeBtn.addEventListener('click', () => this.toggleMode());
                
                const openFrameBtn = document.getElementById('open-frame-btn');
                if (openFrameBtn) openFrameBtn.addEventListener('click', () => {
                    this.setAdjustMode();
                    this.openFrameSelector();
                });
                
                const textureBtn = document.getElementById('texture-btn');
                if (textureBtn) textureBtn.addEventListener('click', () => {
                    this.toggleTextureWindow();
                });
                
                const colorWindowBtn = document.getElementById('color-window-btn');
                if (colorWindowBtn) colorWindowBtn.addEventListener('click', () => {
                    this.setAdjustMode();
                    this.toggleColorWindow();
                });
                
                const reloadFrameBtn = document.getElementById('reload-frame-btn');
                if (reloadFrameBtn) reloadFrameBtn.addEventListener('click', () => {
                    this.setAdjustMode();
                    this.reloadFrame();
                });
                
                const infoWindowBtn = document.getElementById('info-window-btn');
                if (infoWindowBtn) infoWindowBtn.addEventListener('click', () => this.toggleInfoWindow());
                
                const saveImageBtn = document.getElementById('save-image-btn');
                if (saveImageBtn) saveImageBtn.addEventListener('click', () => {
                    this.setAdjustMode();
                    this.saveImage();
                });
                
                // PD値入力
                const topRealSizeInput = document.getElementById('top-real-size');
                if (topRealSizeInput) {
                    topRealSizeInput.addEventListener('change', () => {
                        this.baseRealSize = parseFloat(topRealSizeInput.value) || 60;
                        this.updateRatio();
                        
                        // PD値変更時にフレームを自動更新
                        if (this.originalFrameImage) {
                            this.applyColorAndResize();
                            this.redraw();
                        }
                        
                        this.saveSettings();
                    });
                }
                
                // フレーム実寸入力
                const frameRealSizeInput = document.getElementById('frame-real-size-window');
                if (frameRealSizeInput) {
                    frameRealSizeInput.addEventListener('change', () => {
                        this.frameRealSize = parseFloat(frameRealSizeInput.value) || 160;
                        this.updateFrameSize();
                        
                        // フレーム実寸変更時にフレームを自動更新
                        if (this.originalFrameImage) {
                            this.applyColorAndResize();
                            this.redraw();
                        }
                        
                        this.saveSettings();
                    });
                }
                
                // カラーウィンドウのタブ切り替え
                const tabBtnBlack = document.getElementById('tab-btn-black');
                const tabBtnWhite = document.getElementById('tab-btn-white');
                
                if (tabBtnBlack) tabBtnBlack.addEventListener('click', () => this.switchColorTab('black'));
                if (tabBtnWhite) tabBtnWhite.addEventListener('click', () => this.switchColorTab('white'));
                
                // カラーウィンドウ閉じる
                const colorWindowClose = document.getElementById('color-window-close');
                if (colorWindowClose) colorWindowClose.addEventListener('click', () => this.toggleColorWindow());
                
                // 情報ウィンドウ閉じる
                const infoWindowClose = document.getElementById('info-window-close');
                if (infoWindowClose) infoWindowClose.addEventListener('click', () => this.toggleInfoWindow());
                
                // テクスチャウィンドウ閉じる
                const textureWindowClose = document.getElementById('texture-window-close');
                if (textureWindowClose) textureWindowClose.addEventListener('click', () => this.toggleTextureWindow());
                
                // カラーピッカーのイベント（黒部分）
                this.setupColorPicker('black');
                
                // カラーピッカーのイベント（白部分）
                this.setupColorPicker('white');
                
                // キーボードイベント（リセット機能）
                document.addEventListener('keydown', (e) => {
                    // Shift + C でリセット
                    if (e.shiftKey && e.key === 'C') {
                        e.preventDefault();
                        this.resetAll();
                    }
                });
            }

            setupColorPicker(colorType) {
                const picker = document.getElementById(colorType + '-picker');
                const handle = document.getElementById(colorType + '-handle');
                const hueHandle = document.getElementById(colorType + '-hue-handle');
                const hueTrack = hueHandle.parentElement;
                
                if (!picker || !handle || !hueHandle || !hueTrack) return;
                
                // 2Dカラーピッカー
                let isDragging = false;
                
                const updateColor = (e) => {
                    const rect = picker.getBoundingClientRect();
                    let x = e.clientX - rect.left;
                    let y = e.clientY - rect.top;
                    
                    x = Math.max(0, Math.min(x, rect.width));
                    y = Math.max(0, Math.min(y, rect.height));
                    
                    const saturation = (x / rect.width) * 100;
                    const brightness = 100 - (y / rect.height) * 100;
                    
                    if (colorType === 'black') {
                        this.saturation = saturation;
                        this.brightness = brightness;
                    } else {
                        this.subSaturation = saturation;
                        this.subBrightness = brightness;
                    }
                    
                    handle.style.left = saturation + '%';
                    handle.style.top = (100 - brightness) + '%';
                    
                    this.updateRGBDisplay(colorType);
                    this.applyColorChange();
                };
                
                picker.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    updateColor(e);
                });
                
                // タッチイベント追加
                picker.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    const touch = e.touches[0];
                    updateColor({clientX: touch.clientX, clientY: touch.clientY});
                }, {passive: false});
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        updateColor(e);
                    }
                });
                
                // タッチムーブイベント追加
                document.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        updateColor({clientX: touch.clientX, clientY: touch.clientY});
                    }
                }, {passive: false});
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                // タッチエンド追加
                document.addEventListener('touchend', () => {
                    isDragging = false;
                });
                
                // Hueスライダー
                let isHueDragging = false;
                
                const updateHue = (e) => {
                    const rect = hueTrack.getBoundingClientRect();
                    let x = e.clientX - rect.left;
                    x = Math.max(0, Math.min(x, rect.width));
                    
                    const hue = (x / rect.width) * 360;
                    
                    if (colorType === 'black') {
                        this.hue = hue;
                    } else {
                        this.subHue = hue;
                    }
                    
                    hueHandle.style.left = (hue / 360 * 100) + '%';
                    
                    this.updateColorPickerBackground(colorType);
                    this.updateRGBDisplay(colorType);
                    this.applyColorChange();
                };
                
                hueTrack.addEventListener('mousedown', (e) => {
                    isHueDragging = true;
                    updateHue(e);
                });
                
                // タッチイベント追加
                hueTrack.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isHueDragging = true;
                    const touch = e.touches[0];
                    updateHue({clientX: touch.clientX, clientY: touch.clientY});
                }, {passive: false});
                
                document.addEventListener('mousemove', (e) => {
                    if (isHueDragging) {
                        updateHue(e);
                    }
                });
                
                // タッチムーブイベント追加
                document.addEventListener('touchmove', (e) => {
                    if (isHueDragging && e.touches.length === 1) {
                        const touch = e.touches[0];
                        updateHue({clientX: touch.clientX, clientY: touch.clientY});
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isHueDragging = false;
                });
                
                // タッチエンド追加
                document.addEventListener('touchend', () => {
                    isHueDragging = false;
                });
                
                // 黒部分の透明度スライダー
                if (colorType === 'black') {
                    const opacityHandle = document.getElementById('black-opacity-handle');
                    const opacityTrack = opacityHandle ? opacityHandle.parentElement : null;
                    
                    if (opacityHandle && opacityTrack) {
                        let isOpacityDragging = false;
                        
                        const updateOpacity = (e) => {
                            const rect = opacityTrack.getBoundingClientRect();
                            let x = e.clientX - rect.left;
                            x = Math.max(0, Math.min(x, rect.width));
                            
                            const opacity = (x / rect.width) * 100;
                            this.opacity = opacity;
                            
                            opacityHandle.style.left = opacity + '%';
                            
                            this.updateRGBDisplay(colorType);
                            this.applyColorChange();
                        };
                        
                        opacityTrack.addEventListener('mousedown', (e) => {
                            isOpacityDragging = true;
                            updateOpacity(e);
                        });
                        
                        // タッチイベント追加
                        opacityTrack.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            isOpacityDragging = true;
                            const touch = e.touches[0];
                            updateOpacity({clientX: touch.clientX, clientY: touch.clientY});
                        }, {passive: false});
                        
                        document.addEventListener('mousemove', (e) => {
                            if (isOpacityDragging) {
                                updateOpacity(e);
                            }
                        });
                        
                        // タッチムーブイベント追加
                        document.addEventListener('touchmove', (e) => {
                            if (isOpacityDragging && e.touches.length === 1) {
                                const touch = e.touches[0];
                                updateOpacity({clientX: touch.clientX, clientY: touch.clientY});
                            }
                        });
                        
                        document.addEventListener('mouseup', () => {
                            isOpacityDragging = false;
                        });
                        
                        // タッチエンド追加
                        document.addEventListener('touchend', () => {
                            isOpacityDragging = false;
                        });
                    }
                }
                
                // 白部分の透明度スライダー
                if (colorType === 'white') {
                    const opacityHandle = document.getElementById('white-opacity-handle');
                    const opacityTrack = opacityHandle.parentElement;
                    
                    if (opacityHandle && opacityTrack) {
                        let isOpacityDragging = false;
                        
                        const updateOpacity = (e) => {
                            const rect = opacityTrack.getBoundingClientRect();
                            let x = e.clientX - rect.left;
                            x = Math.max(0, Math.min(x, rect.width));
                            
                            const opacity = (x / rect.width) * 100;
                            this.subOpacity = opacity;
                            
                            opacityHandle.style.left = opacity + '%';
                            
                            this.updateRGBDisplay(colorType);
                            this.applyColorChange();
                        };
                        
                        opacityTrack.addEventListener('mousedown', (e) => {
                            isOpacityDragging = true;
                            updateOpacity(e);
                        });
                        
                        // タッチイベント追加
                        opacityTrack.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            isOpacityDragging = true;
                            const touch = e.touches[0];
                            updateOpacity({clientX: touch.clientX, clientY: touch.clientY});
                        }, {passive: false});
                        
                        document.addEventListener('mousemove', (e) => {
                            if (isOpacityDragging) {
                                updateOpacity(e);
                            }
                        });
                        
                        // タッチムーブイベント追加
                        document.addEventListener('touchmove', (e) => {
                            if (isOpacityDragging && e.touches.length === 1) {
                                const touch = e.touches[0];
                                updateOpacity({clientX: touch.clientX, clientY: touch.clientY});
                            }
                        });
                        
                        document.addEventListener('mouseup', () => {
                            isOpacityDragging = false;
                        });
                        
                        // タッチエンド追加
                        document.addEventListener('touchend', () => {
                            isOpacityDragging = false;
                        });
                    }
                }
                
                // 初期位置設定
                this.updateColorPickerUI(colorType);
            }

            updateColorPickerBackground(colorType) {
                const picker = document.getElementById(colorType + '-picker');
                if (!picker) return;
                
                const hue = colorType === 'black' ? this.hue : this.subHue;
                const hueColor = this.hsvToRgb(hue / 360, 1, 1);
                const rgb = `rgb(${Math.round(hueColor.r * 255)}, ${Math.round(hueColor.g * 255)}, ${Math.round(hueColor.b * 255)})`;
                
                picker.style.background = `linear-gradient(to bottom, transparent, black), linear-gradient(to right, white, ${rgb})`;
            }

            updateColorPickerUI(colorType) {
                if (colorType === 'black') {
                    const handle = document.getElementById('black-handle');
                    if (handle) {
                        handle.style.left = this.saturation + '%';
                        handle.style.top = (100 - this.brightness) + '%';
                    }
                    
                    const hueHandle = document.getElementById('black-hue-handle');
                    if (hueHandle) {
                        hueHandle.style.left = (this.hue / 360 * 100) + '%';
                    }
                    
                    const opacityHandle = document.getElementById('black-opacity-handle');
                    if (opacityHandle) {
                        opacityHandle.style.left = this.opacity + '%';
                    }
                    
                    this.updateRGBDisplay('black');
                    this.updateColorPickerBackground('black');
                } else {
                    const handle = document.getElementById('white-handle');
                    if (handle) {
                        handle.style.left = this.subSaturation + '%';
                        handle.style.top = (100 - this.subBrightness) + '%';
                    }
                    
                    const hueHandle = document.getElementById('white-hue-handle');
                    if (hueHandle) {
                        hueHandle.style.left = (this.subHue / 360 * 100) + '%';
                    }
                    
                    const opacityHandle = document.getElementById('white-opacity-handle');
                    if (opacityHandle) {
                        opacityHandle.style.left = this.subOpacity + '%';
                    }
                    
                    this.updateRGBDisplay('white');
                    this.updateColorPickerBackground('white');
                }
            }

            updateRGBDisplay(colorType) {
                let h, s, v;
                if (colorType === 'black') {
                    h = this.hue / 360;
                    s = this.saturation / 100;
                    v = this.brightness / 100;
                } else {
                    h = this.subHue / 360;
                    s = this.subSaturation / 100;
                    v = this.subBrightness / 100;
                }
                
                const rgb = this.hsvToRgb(h, s, v);
                const r = Math.round(rgb.r * 255);
                const g = Math.round(rgb.g * 255);
                const b = Math.round(rgb.b * 255);
                
                const rEl = document.getElementById(colorType + '-r');
                const gEl = document.getElementById(colorType + '-g');
                const bEl = document.getElementById(colorType + '-b');
                
                if (rEl) rEl.textContent = r;
                if (gEl) gEl.textContent = g;
                if (bEl) bEl.textContent = b;
                
                const aEl = document.getElementById(colorType + '-a');
                if (aEl) {
                    if (colorType === 'black') {
                        aEl.textContent = Math.round(this.opacity);
                    } else {
                        aEl.textContent = Math.round(this.subOpacity);
                    }
                }
            }

            switchColorTab(tab) {
                this.currentColorTab = tab;
                
                // タブボタンの状態を更新
                const tabs = ['black', 'white'];
                tabs.forEach(t => {
                    const btn = document.getElementById('tab-btn-' + t);
                    const content = document.getElementById('tab-' + t);
                    if (btn) {
                        if (t === tab) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    }
                    if (content) {
                        if (t === tab) {
                            content.classList.add('active');
                        } else {
                            content.classList.remove('active');
                        }
                    }
                });
            }

            toggleColorWindow() {
                this.colorWindowVisible = !this.colorWindowVisible;
                const window = document.getElementById('color-window');
                
                if (this.colorWindowVisible) {
                    window.classList.add('show');
                    this.updateColorPickerUI(this.currentColorTab);
                } else {
                    window.classList.remove('show');
                }
            }

            toggleInfoWindow() {
                this.infoWindowVisible = !this.infoWindowVisible;
                const window = document.getElementById('info-window');
                
                if (this.infoWindowVisible) {
                    window.classList.add('show');
                    this.updateInfoWindowContent();
                } else {
                    window.classList.remove('show');
                }
            }

            updateInfoWindowContent() {
                // 顔写真情報
                const faceFileName = document.getElementById('face-file-name-window');
                if (faceFileName) {
                    faceFileName.textContent = this.baseImageName || '未選択';
                }
                
                // 測定情報
                const pixelDistance = document.getElementById('pixel-distance-window');
                if (pixelDistance) {
                    pixelDistance.textContent = this.pixelDistance > 0 ? `${this.pixelDistance.toFixed(2)}px` : '--px';
                }
                
                const realDistance = document.getElementById('real-distance-window');
                if (realDistance) {
                    realDistance.textContent = this.baseRealSize;
                }
                
                const scaleRatio = document.getElementById('scale-ratio-window');
                if (scaleRatio) {
                    scaleRatio.textContent = this.scaleRatio > 0 ? this.scaleRatio.toFixed(4) : '--';
                }
                
                // フレーム情報
                const frameFileName = document.getElementById('frame-file-name-window');
                if (frameFileName) {
                    frameFileName.textContent = this.frameImageName || '未選択';
                }
                
                const frameRealSize = document.getElementById('frame-real-size-window');
                if (frameRealSize) {
                    frameRealSize.value = this.frameRealSize;
                }
                
                // カラー情報
                const colorBlack = document.getElementById('color-black-window');
                const colorWhite = document.getElementById('color-white-window');
                
                if (colorBlack) {
                    // 黒部分のRGB値を計算
                    const h = this.hue / 360;
                    const s = this.saturation / 100;
                    const v = this.brightness / 100;
                    const rgb = this.hsvToRgb(h, s, v);
                    const r = Math.round(rgb.r * 255);
                    const g = Math.round(rgb.g * 255);
                    const b = Math.round(rgb.b * 255);
                    const a = Math.round(this.opacity);
                    
                    colorBlack.textContent = `RGB(${r}, ${g}, ${b}) A:${a}`;
                }
                
                if (colorWhite) {
                    // 白部分のRGB値を計算
                    const h = this.subHue / 360;
                    const s = this.subSaturation / 100;
                    const v = this.subBrightness / 100;
                    const rgb = this.hsvToRgb(h, s, v);
                    const r = Math.round(rgb.r * 255);
                    const g = Math.round(rgb.g * 255);
                    const b = Math.round(rgb.b * 255);
                    const a = Math.round(this.subOpacity);
                    
                    colorWhite.textContent = `RGB(${r}, ${g}, ${b}) A:${a}`;
                }
                
                // サイズ計算
                const calc160 = document.getElementById('calc-160-window');
                
                if (this.scaleRatio > 0) {
                    if (calc160) calc160.textContent = `? 160mm: ${(160 * this.scaleRatio).toFixed(2)}px`;
                } else {
                    if (calc160) calc160.textContent = '? 160mm: --px (比率未設定)';
                }
                
                // 測定点情報
                const measurementPoints = document.getElementById('measurement-points-window');
                if (measurementPoints) {
                    if (this.measurementPoints.length === 0) {
                        measurementPoints.textContent = '測定点なし';
                    } else {
                        let html = '';
                        this.measurementPoints.forEach((point, index) => {
                            html += `? 点${index + 1}: (${Math.round(point.x)}, ${Math.round(point.y)})<br>`;
                        });
                        measurementPoints.innerHTML = html;
                    }
                }
            }

            toggleMode() {
                if (this.mode === 'measure') {
                    this.setAdjustMode();
                } else {
                    this.setMeasureMode();
                }
            }

            setMeasureMode() {
                this.mode = 'measure';
                this.updateModeButton();
                this.updateStatusBar();
                // 測定モードに切り替えたら拡大鏡を表示
                if (this.baseImage) {
                    this.magnifier.classList.add('show');
                }
                this.redraw();
            }

            setAdjustMode() {
                this.mode = 'adjust';
                this.updateModeButton();
                this.updateStatusBar();
                // 移動モードに切り替えたら拡大鏡を非表示
                this.magnifier.classList.remove('show');
                this.redraw();
            }

            updateModeButton() {
                const btn = document.getElementById('top-mode-button');
                if (!btn) return;
                
                // アイコンは常にメジャー、色は変更しない
                btn.innerHTML = '<span class="icon">straighten</span>';
                
                if (this.mode === 'measure') {
                    btn.classList.remove('mode-adjust');
                    btn.classList.add('mode-measure');
                    btn.title = '測定モード';
                } else {
                    btn.classList.remove('mode-measure');
                    btn.classList.add('mode-adjust');
                    btn.title = '移動モード';
                }
            }

            openFaceImage() {
                this.faceInput.value = ''; // ファイル選択状態をクリア
                this.faceInput.click();
            }

            loadFaceImage(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.baseImageName = file.name;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.baseImage = img;
                        this.resizeCanvas();
                        this.redraw();
                        this.updateStatusBar();
                        this.updateInfoWindowContent();
                        this.updateProductName();
                        
                        // 測定モードの場合は拡大鏡を表示
                        if (this.mode === 'measure') {
                            this.magnifier.classList.add('show');
                        }
                        
                        this.saveSettings();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            openFrameImage() {
                this.frameInput.value = ''; // ファイル選択状態をクリア
                this.frameInput.click();
            }

            loadFrameImage(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.frameImageName = file.name;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalFrameImage = img;
                        this.originalFrameSize = {
                            width: img.width,
                            height: img.height
                        };
                        // フレーム読み込み後、現在のテクスチャ状態に応じて処理
                        if (this.currentTexture === null) {
                            // テクスチャなし - カラー設定を適用
                            this.applyColorAndResize();
                        } else {
                            // テクスチャあり - テクスチャ処理を適用
                            this.applyTextureAndResize();
                        }
                        // 即座に再描画
                        this.redraw();
                        this.updateStatusBar();
                        this.updateInfoWindowContent();
                        this.updateProductName();
                        this.saveSettings();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            async reloadFrame() {
                // ステータスバーで更新開始を通知
                this.updateStatusBar('フレーム・テクスチャデータを更新中...');
                
                try {
                    // フレームJSONを強制更新
                    await this.forceReloadFrameList();
                    
                    // テクスチャJSONを強制更新
                    await this.forceReloadTextureList();
                    
                    // フレーム画像も再適用
                    if (this.originalFrameImage) {
                        // 現在のテクスチャ状態に応じて処理
                        if (this.currentTexture === null) {
                            this.applyColorAndResize();
                        } else {
                            this.applyTextureAndResize();
                        }
                        this.redraw();
                        this.updateStatusBar();
                    }
                    
                    console.log('フレーム・テクスチャデータの更新が完了しました');
                    this.updateStatusBar('フレーム・テクスチャデータ更新完了');
                    
                } catch (error) {
                    console.error('データ更新エラー:', error);
                    this.updateStatusBar('データ更新に失敗しました');
                }
            }

            applyColorAndResize() {
                if (!this.originalFrameImage) return;
                
                // フレームサイズの計算
                if (this.scaleRatio > 0) {
                    const targetWidth = this.frameRealSize * this.scaleRatio;
                    const scale = targetWidth / this.originalFrameSize.width;
                    this.frameSize = {
                        width: this.originalFrameSize.width * scale,
                        height: this.originalFrameSize.height * scale
                    };
                } else {
                    this.frameSize = {
                        width: this.originalFrameSize.width,
                        height: this.originalFrameSize.height
                    };
                }
                
                // カラーとパターンを適用
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.originalFrameSize.width;
                tempCanvas.height = this.originalFrameSize.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.drawImage(this.originalFrameImage, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                
                this.applyColorToFrame(imageData);
                
                tempCtx.putImageData(imageData, 0, 0);
                
                // リサイズ
                const resizedCanvas = document.createElement('canvas');
                resizedCanvas.width = this.frameSize.width;
                resizedCanvas.height = this.frameSize.height;
                const resizedCtx = resizedCanvas.getContext('2d');
                
                resizedCtx.drawImage(tempCanvas, 0, 0, this.frameSize.width, this.frameSize.height);
                
                // 即座にframeImageを更新
                const dataURL = resizedCanvas.toDataURL();
                this.frameImage = new Image();
                this.frameImage.onload = () => {
                    // 画像が読み込まれたら再描画
                    this.redraw();
                };
                this.frameImage.src = dataURL;
            }

            applyColorToFrame(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                // メインカラー（黒部分用）HSBからRGBへ変換
                const mainRgb = this.hsvToRgb(this.hue / 360, this.saturation / 100, this.brightness / 100);
                const mainR = Math.round(mainRgb.r * 255);
                const mainG = Math.round(mainRgb.g * 255);
                const mainB = Math.round(mainRgb.b * 255);
                const mainAlpha = this.opacity / 100; // 黒部分の透過率
                
                // サブカラー（白部分用）HSBからRGBへ変換
                const subRgb = this.hsvToRgb(this.subHue / 360, this.subSaturation / 100, this.subBrightness / 100);
                const subR = Math.round(subRgb.r * 255);
                const subG = Math.round(subRgb.g * 255);
                const subB = Math.round(subRgb.b * 255);
                const subAlpha = this.subOpacity / 100; // 白部分の透過率

                for (let i = 0; i < data.length; i += 4) {
                    const sum = data[i] + data[i + 1] + data[i + 2];
                    
                    // 黒っぽい部分（メインカラー）
                    if (sum < 60) {
                        data[i] = mainR;
                        data[i + 1] = mainG;
                        data[i + 2] = mainB;
                        data[i + 3] = Math.round(data[i + 3] * mainAlpha);
                    }
                    // 白っぽい部分（サブカラー）
                    else if (sum > 700) { // 白判定の閾値（RGB合計が700以上）
                        data[i] = subR;
                        data[i + 1] = subG;
                        data[i + 2] = subB;
                        data[i + 3] = Math.round(255 * subAlpha); // 透過率を適用
                    }
                }
            }

            hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);
                
                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }
                
                return {r, g, b};
            }

            // カラー調整デバウンス用タイマー
            colorUpdateTimer = null;
            
            applyColorChange() {
                // デバウンス処理（100ms遅延）
                clearTimeout(this.colorUpdateTimer);
                this.colorUpdateTimer = setTimeout(() => {
                    this.performColorUpdate();
                }, 100);
            }
            
            performColorUpdate() {
                if (this.frameImage) {
                    // 現在のテクスチャ状態に応じて適切な処理を選択
                    if (this.currentTexture === null) {
                        // テクスチャなし - カラー設定を適用
                        this.applyColorAndResize();
                    } else {
                        // テクスチャあり - テクスチャ処理を適用（白部分のみカラー更新）
                        this.applyTextureAndResize();
                    }
                    setTimeout(() => this.redraw(), 50);
                }
                // 情報ウィンドウが開いている場合は更新
                if (this.infoWindowVisible) {
                    this.updateInfoWindowContent();
                }
                this.saveSettings();
            }

            updateFrameSize() {
                if (this.originalFrameImage) {
                    // 現在のテクスチャ状態に応じて適切な処理を選択
                    if (this.currentTexture === null) {
                        // テクスチャなし - カラー設定を適用
                        this.applyColorAndResize();
                    } else {
                        // テクスチャあり - テクスチャ処理を適用
                        this.applyTextureAndResize();
                    }
                    this.redraw();
                }
                this.updateInfoWindowContent();
                this.saveSettings();
            }

            updateProductName() {
                const display = document.getElementById('product-name-display');
                if (display) {
                    if (this.frameImageName) {
                        const name = this.frameImageName.replace(/\.[^/.]+$/, '');
                        display.textContent = name;
                    } else {
                        display.textContent = '製品名なし';
                    }
                }
            }

            resizeCanvas() {
                const container = document.getElementById('canvas-container');
                const rect = container.getBoundingClientRect();
                
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // 拡大鏡キャンバスのサイズ設定
                this.magnifierCanvas.width = 220;
                this.magnifierCanvas.height = 220;
                
                this.redraw();
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.baseImage) {
                    const scale = Math.min(
                        this.canvas.width / this.baseImage.width,
                        this.canvas.height / this.baseImage.height
                    );
                    
                    const width = this.baseImage.width * scale;
                    const height = this.baseImage.height * scale;
                    const x = (this.canvas.width - width) / 2;
                    const y = (this.canvas.height - height) / 2;
                    
                    this.ctx.drawImage(this.baseImage, x, y, width, height);
                    
                    if (this.frameImage) {
                        this.ctx.drawImage(
                            this.frameImage,
                            x + this.frameOffset.x * scale,
                            y + this.frameOffset.y * scale,
                            this.frameSize.width * scale,
                            this.frameSize.height * scale
                        );
                    }
                    
                    // 測定点の描画（測定モードの時のみ）
                    if (this.mode === 'measure') {
                        this.measurementPoints.forEach((point, index) => {
                            this.ctx.fillStyle = 'red';
                            this.ctx.beginPath();
                            this.ctx.arc(
                                x + point.x * scale,
                                y + point.y * scale,
                                5, 0, 2 * Math.PI
                            );
                            this.ctx.fill();
                            
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = '14px Arial';
                            this.ctx.fillText(
                                (index + 1).toString(),
                                x + point.x * scale + 8,
                                y + point.y * scale - 8
                            );
                        });
                        
                        // 測定線の描画（測定モードの時のみ）
                        if (this.measurementPoints.length === 2) {
                            this.ctx.strokeStyle = 'yellow';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(
                                x + this.measurementPoints[0].x * scale,
                                y + this.measurementPoints[0].y * scale
                            );
                            this.ctx.lineTo(
                                x + this.measurementPoints[1].x * scale,
                                y + this.measurementPoints[1].y * scale
                            );
                            this.ctx.stroke();
                        }
                    }
                }
            }

            updateMagnifier(clientX, clientY) {
                if (!this.baseImage) return;
                
                // 測定モードの時は常に拡大鏡を表示
                if (this.mode !== 'measure') {
                    this.magnifier.classList.remove('show');
                    return;
                } else {
                    this.magnifier.classList.add('show');
                }
                
                const rect = this.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                const scale = Math.min(
                    this.canvas.width / this.baseImage.width,
                    this.canvas.height / this.baseImage.height
                );
                
                const imgX = (this.canvas.width - this.baseImage.width * scale) / 2;
                const imgY = (this.canvas.height - this.baseImage.height * scale) / 2;
                
                // 画像外でも拡大鏡を更新（測定モードでは常に表示）
                let sourceX, sourceY;
                
                if (x >= imgX && x <= imgX + this.baseImage.width * scale &&
                    y >= imgY && y <= imgY + this.baseImage.height * scale) {
                    // 画像内の場合
                    sourceX = (x - imgX) / scale;
                    sourceY = (y - imgY) / scale;
                } else {
                    // 画像外の場合は境界にクランプ
                    sourceX = Math.max(0, Math.min(this.baseImage.width, (x - imgX) / scale));
                    sourceY = Math.max(0, Math.min(this.baseImage.height, (y - imgY) / scale));
                }
                
                const magnifierSize = 220;
                const sourceSize = magnifierSize / this.magnifierZoom;
                
                this.magnifierCtx.clearRect(0, 0, magnifierSize, magnifierSize);
                
                this.magnifierCtx.drawImage(
                    this.baseImage,
                    Math.max(0, sourceX - sourceSize / 2),
                    Math.max(0, sourceY - sourceSize / 2),
                    sourceSize,
                    sourceSize,
                    0, 0,
                    magnifierSize,
                    magnifierSize
                );
            }

            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (!this.baseImage) return;
                
                const scale = Math.min(
                    this.canvas.width / this.baseImage.width,
                    this.canvas.height / this.baseImage.height
                );
                
                const imgX = (this.canvas.width - this.baseImage.width * scale) / 2;
                const imgY = (this.canvas.height - this.baseImage.height * scale) / 2;
                
                const relX = (x - imgX) / scale;
                const relY = (y - imgY) / scale;
                
                if (this.mode === 'measure') {
                    // 既存の測定点をクリックしたかチェック（画面座標で30ピクセル）
                    let clickedPointIndex = -1;
                    for (let i = 0; i < this.measurementPoints.length; i++) {
                        const point = this.measurementPoints[i];
                        // 画面座標での距離を計算
                        const screenPointX = imgX + point.x * scale;
                        const screenPointY = imgY + point.y * scale;
                        const screenDist = Math.sqrt(
                            Math.pow(x - screenPointX, 2) + 
                            Math.pow(y - screenPointY, 2)
                        );
                        if (screenDist < 30) { // 画面座標で30ピクセル
                            clickedPointIndex = i;
                            break;
                        }
                    }
                    
                    if (clickedPointIndex >= 0) {
                        this.draggingPointIndex = clickedPointIndex;
                    } else {
                        // 新しい測定点を追加
                        if (this.measurementPoints.length < 2) {
                            this.measurementPoints.push({x: relX, y: relY});
                            
                            if (this.measurementPoints.length === 2) {
                                this.calculateDistance();
                            }
                            
                            this.redraw();
                            this.updateStatusBar();
                            this.updateInfoWindowContent();
                        }
                    }
                } else if (this.mode === 'adjust' && this.frameImage) {
                    const frameX = imgX + this.frameOffset.x * scale;
                    const frameY = imgY + this.frameOffset.y * scale;
                    const frameW = this.frameSize.width * scale;
                    const frameH = this.frameSize.height * scale;
                    
                    if (x >= frameX && x <= frameX + frameW &&
                        y >= frameY && y <= frameY + frameH) {
                        this.dragging = true;
                        this.dragStart = {
                            x: x - this.frameOffset.x * scale,
                            y: y - this.frameOffset.y * scale
                        };
                    }
                }
            }

            onMouseMove(e) {
                if (!this.baseImage) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const scale = Math.min(
                    this.canvas.width / this.baseImage.width,
                    this.canvas.height / this.baseImage.height
                );
                
                const imgX = (this.canvas.width - this.baseImage.width * scale) / 2;
                const imgY = (this.canvas.height - this.baseImage.height * scale) / 2;
                
                const relX = (x - imgX) / scale;
                const relY = (y - imgY) / scale;
                
                if (this.mode === 'measure' && this.draggingPointIndex >= 0) {
                    this.measurementPoints[this.draggingPointIndex] = {x: relX, y: relY};
                    
                    if (this.measurementPoints.length === 2) {
                        this.calculateDistance();
                    }
                    
                    this.redraw();
                    this.updateStatusBar();
                    this.updateInfoWindowContent();
                } else if (this.mode === 'adjust' && this.dragging) {
                    this.frameOffset.x = (x - this.dragStart.x) / scale;
                    this.frameOffset.y = (y - this.dragStart.y) / scale;
                    this.redraw();
                }
            }

            onMouseUp(e) {
                this.dragging = false;
                this.draggingPointIndex = -1;
            }

            onTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    
                    // 拡大鏡を更新
                    if (this.mode === 'measure' && this.baseImage) {
                        this.updateMagnifier(touch.clientX, touch.clientY);
                    }
                    
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.onMouseDown(mouseEvent);
                }
            }

            onTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    
                    // 拡大鏡を更新
                    if (this.mode === 'measure' && this.baseImage) {
                        this.updateMagnifier(touch.clientX, touch.clientY);
                    }
                    
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.onMouseMove(mouseEvent);
                }
            }

            onTouchEnd(e) {
                e.preventDefault();
                if (e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    const mouseEvent = new MouseEvent('mouseup', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.onMouseUp(mouseEvent);
                }
            }

            calculateDistance() {
                if (this.measurementPoints.length !== 2) return;
                
                const p1 = this.measurementPoints[0];
                const p2 = this.measurementPoints[1];
                
                this.pixelDistance = Math.sqrt(
                    Math.pow(p2.x - p1.x, 2) + 
                    Math.pow(p2.y - p1.y, 2)
                );
                
                this.updateRatio();
                
                // 測定完了時にフレームを自動更新
                if (this.originalFrameImage) {
                    this.applyColorAndResize();
                    this.redraw();
                }
            }

            updateRatio() {
                if (this.pixelDistance > 0 && this.baseRealSize > 0) {
                    this.scaleRatio = this.pixelDistance / this.baseRealSize;
                    this.updateFrameSize();
                    this.updateStatusBar();
                    this.updateInfoWindowContent();
                }
            }

            updateStatusBar(customMessage = null) {
                const statusBar = document.getElementById('status-bar');
                if (!statusBar) return;
                
                // カスタムメッセージが指定された場合はそれを表示
                if (customMessage) {
                    statusBar.textContent = customMessage;
                    return;
                }
                
                let status = '';
                
                if (!this.baseImage) {
                    status = '顔写真を開いてください';
                } else if (this.mode === 'measure') {
                    if (this.measurementPoints.length === 0) {
                        status = '測定モード: 2点をクリックして距離を測定';
                    } else if (this.measurementPoints.length === 1) {
                        status = '測定モード: 2点目をクリック';
                    } else {
                        status = `測定完了: ${this.pixelDistance.toFixed(2)}px = ${this.baseRealSize}mm (比率: ${this.scaleRatio.toFixed(4)} px/mm)`;
                    }
                } else if (this.mode === 'adjust') {
                    status = this.frameImage ? 
                        '移動モード: フレームをドラッグして位置を調整' : 
                        'フレームを開いてください';
                }
                
                statusBar.textContent = status;
            }

            saveImage() {
                if (!this.baseImage) {
                    alert('画像が読み込まれていません');
                    return;
                }
                
                // 現在の日時から月日時分を取得
                const now = new Date();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                
                // フレーム名から拡張子を除去
                const frameName = this.frameImageName ? this.frameImageName.replace(/\.[^/.]+$/, '') : 'noframe';
                
                // ファイル名: 月日時分_フレーム名
                const fileName = `${month}${day}${hours}${minutes}_${frameName}.png`;
                
                const link = document.createElement('a');
                link.download = fileName;
                link.href = this.canvas.toDataURL();
                link.click();
            }

            // フレーム選択関連の機能
            async openFrameSelector() {
                const modal = document.getElementById('frame-selector-modal');
                modal.style.display = 'flex';
                
                if (this.availableFrames.length === 0) {
                    await this.loadFrameList();
                }
                
                this.setupFrameFilters();
                this.updateFrameFilters();
                
                // フィルター表示状態を復元
                const filterDiv = document.getElementById('frame-filters');
                const toggleBtn = document.getElementById('filter-toggle-btn');
                const icon = toggleBtn.querySelector('.icon');
                
                if (this.filterVisible) {
                    filterDiv.classList.add('show');
                    icon.textContent = 'expand_less';
                } else {
                    filterDiv.classList.remove('show');
                    icon.textContent = 'expand_more';
                }
            }

            closeFrameSelector() {
                const modal = document.getElementById('frame-selector-modal');
                modal.style.display = 'none';
            }

            toggleFrameFilter() {
                this.filterVisible = !this.filterVisible;
                const filterDiv = document.getElementById('frame-filters');
                const toggleBtn = document.getElementById('filter-toggle-btn');
                const icon = toggleBtn.querySelector('.icon');
                
                if (this.filterVisible) {
                    filterDiv.classList.add('show');
                    icon.textContent = 'expand_less';
                } else {
                    filterDiv.classList.remove('show');
                    icon.textContent = 'expand_more';
                }
            }

            async forceReloadFrameList() {
                try {
                    // キャッシュをクリアして最新データを取得
                    const response = await fetch('./frames/frame-list.json', {
                        cache: 'no-cache'
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    
                    // データを強制更新
                    this.availableFrames = data.frames || data;
                    console.log(`フレームリスト更新: ${this.availableFrames.length}個のフレームを読み込みました`);
                    
                    // フィルターもリセット
                    this.filteredFrames = [...this.availableFrames];
                    
                } catch (error) {
                    console.error('フレームリストの更新に失敗:', error);
                    throw error;
                }
            }

            async forceReloadTextureList() {
                try {
                    // キャッシュをクリアして最新データを取得
                    const response = await fetch('./textures/texture-list.json', {
                        cache: 'no-cache'
                    });
                    if (!response.ok) {
                        console.log('texture-list.json が見つかりません（正常）');
                        return;
                    }
                    const data = await response.json();
                    
                    // データを強制更新
                    if (Array.isArray(data)) {
                        this.availableTextures = data.map(filename => ({
                            name: this.filenameToDisplayName(filename),
                            type: 'image',
                            file: filename
                        }));
                    } else if (data.textures && Array.isArray(data.textures)) {
                        const textureArray = data.textures;
                        this.availableTextures = textureArray.map(item => {
                            if (typeof item === 'string') {
                                return {
                                    name: this.filenameToDisplayName(item),
                                    type: 'image',
                                    file: item
                                };
                            } else {
                                return item;
                            }
                        });
                    }
                    
                    console.log(`テクスチャリスト更新: ${this.availableTextures.length}個のテクスチャを読み込みました`);
                    
                } catch (error) {
                    console.log('テクスチャリストの更新をスキップ:', error);
                    // テクスチャは必須ではないのでエラーにしない
                }
            }

            async loadFrameList() {
                try {
                    const response = await fetch('./frames/frame-list.json', {
                        cache: 'no-cache'
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    this.availableFrames = data.frames || data;
                    console.log(`${this.availableFrames.length}個のフレームを読み込みました`);
                    
                    // 初期状態で全フレームを表示（フィルターなし）
                    this.filteredFrames = [...this.availableFrames];
                    
                } catch (error) {
                    console.error('フレームリストの読み込みに失敗:', error);
                    this.availableFrames = [];
                    this.filteredFrames = [];
                    const grid = document.getElementById('frame-grid');
                    if (grid) {
                        grid.innerHTML = '<div class="loading">フレームリストの読み込みに失敗しました</div>';
                    }
                }
            }

            setupFrameFilters() {
                // シリーズ名を抽出
                const seriesSet = new Set();

                this.availableFrames.forEach(frame => {
                    const filename = typeof frame === 'string' ? frame : frame.filename;
                    const parsed = this.parseFrameFilename(filename);
                    if (parsed) {
                        seriesSet.add(parsed.series);
                    }
                });

                // フィルターUIを作成
                this.createFilterUI('series-filters', Array.from(seriesSet).sort());
                this.setupRangeSliders();
                
                // グリッドサイズを更新
                this.updateGridLayout();
            }

            parseFrameFilename(filename) {
                const match = filename.match(/(.+?)(\d{3})_PD(\d+)_OW(\d+)(?:_v[\d\.]+|_\d{8}|_build\d+|_rev\d+)*\.png/);

                if (match) {
                    return {
                        series: match[1] + match[2],
                        number: match[2],
                        pd: parseInt(match[3]),
                        ow: parseInt(match[4])
                    };
                }
                return null;
            }

            calculateGridColumns() {
                const physicalWidth = window.screen.width;
                return physicalWidth >= 980 ? 5 : 3;
            }

            setupRangeSliders() {
                // PDスライダーの設定
                const pdMin = document.getElementById('pd-min');
                const pdMax = document.getElementById('pd-max');
                const pdValues = document.getElementById('pd-values');
                
                pdMin.min = this.pdAvailableRange.min;
                pdMin.max = this.pdAvailableRange.max;
                pdMax.min = this.pdAvailableRange.min;
                pdMax.max = this.pdAvailableRange.max;
                
                // 保存された値を復元、なければ全範囲
                pdMin.value = this.pdRange.min || this.pdAvailableRange.min;
                pdMax.value = this.pdRange.max || this.pdAvailableRange.max;
                
                this.updateRangeValues('pd');
                
                // OWスライダーの設定
                const owMin = document.getElementById('ow-min');
                const owMax = document.getElementById('ow-max');
                const owValues = document.getElementById('ow-values');
                
                owMin.min = this.owAvailableRange.min;
                owMin.max = this.owAvailableRange.max;
                owMax.min = this.owAvailableRange.min;
                owMax.max = this.owAvailableRange.max;
                
                // 保存された値を復元、なければ全範囲
                owMin.value = this.owRange.min || this.owAvailableRange.min;
                owMax.value = this.owRange.max || this.owAvailableRange.max;
                
                this.updateRangeValues('ow');
                
                // イベントリスナーの設定
                pdMin.addEventListener('input', () => {
                    if (parseInt(pdMin.value) > parseInt(pdMax.value)) {
                        pdMin.value = pdMax.value;
                    }
                    this.updateRangeValues('pd');
                });
                
                pdMax.addEventListener('input', () => {
                    if (parseInt(pdMax.value) < parseInt(pdMin.value)) {
                        pdMax.value = pdMin.value;
                    }
                    this.updateRangeValues('pd');
                });
                
                owMin.addEventListener('input', () => {
                    if (parseInt(owMin.value) > parseInt(owMax.value)) {
                        owMin.value = owMax.value;
                    }
                    this.updateRangeValues('ow');
                });
                
                owMax.addEventListener('input', () => {
                    if (parseInt(owMax.value) < parseInt(owMin.value)) {
                        owMax.value = owMin.value;
                    }
                    this.updateRangeValues('ow');
                });
            }
            
            updateGridLayout() {
                const frameGrid = document.querySelector('.frame-grid');
                if (!frameGrid) return;
                
                // アイテム幅 = 画像幅 + padding 16px
                const itemWidth = this.logicalImageWidth + 16;
                
                // グリッドを更新
                frameGrid.style.gridTemplateColumns = `repeat(${this.gridColumns}, ${itemWidth}px)`;
                
                // 既存の画像サイズも更新
                this.updateAllFrameItemSizes();
            }
            
            updateAllFrameItemSizes() {
                const images = document.querySelectorAll('.frame-item img');
                images.forEach(img => {
                    img.style.width = this.logicalImageWidth + 'px';
                    img.style.height = this.logicalImageHeight + 'px';
                });
            }

            updateRangeValues(type) {
                if (type === 'pd') {
                    const pdMin = document.getElementById('pd-min');
                    const pdMax = document.getElementById('pd-max');
                    const pdValues = document.getElementById('pd-values');
                    pdValues.textContent = `${pdMin.value} - ${pdMax.value}`;
                    this.pdRange.min = parseInt(pdMin.value);
                    this.pdRange.max = parseInt(pdMax.value);
                } else if (type === 'ow') {
                    const owMin = document.getElementById('ow-min');
                    const owMax = document.getElementById('ow-max');
                    const owValues = document.getElementById('ow-values');
                    owValues.textContent = `${owMin.value} - ${owMax.value}`;
                    this.owRange.min = parseInt(owMin.value);
                    this.owRange.max = parseInt(owMax.value);
                }
            }

            createFilterUI(containerId, values) {
                const container = document.getElementById(containerId);
                if (!container) return;

                const filterType = containerId.replace('-filters', '');
                const savedSelection = this.selectedFilters[filterType] || [];

                container.innerHTML = '';
                values.forEach(value => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `${containerId}-${value}`;
                    checkbox.value = value;
                    
                    // 保存されている選択状態を復元（型を文字列に統一）
                    if (savedSelection.includes(String(value))) {
                        checkbox.checked = true;
                    }
                    
                    // チェック状態が変更されたら保存
                    checkbox.addEventListener('change', () => {
                        this.saveFilterSelection(filterType);
                    });

                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.textContent = value;

                    container.appendChild(checkbox);
                    container.appendChild(label);
                });
            }

            saveFilterSelection(filterType) {
                const containerId = filterType + '-filters';
                const values = this.getSelectedFilterValues(containerId);
                this.selectedFilters[filterType] = values;
            }

            clearFilterSelection() {
                // すべてのチェックボックスを外す
                const seriesContainer = document.getElementById('series-filters');
                if (seriesContainer) {
                    const checkboxes = seriesContainer.querySelectorAll('input[type="checkbox"]');
                    checkboxes.forEach(cb => cb.checked = false);
                }
                
                // レンジスライダーを全範囲に戻す
                const pdMin = document.getElementById('pd-min');
                const pdMax = document.getElementById('pd-max');
                const owMin = document.getElementById('ow-min');
                const owMax = document.getElementById('ow-max');
                
                if (pdMin && pdMax) {
                    pdMin.value = this.pdAvailableRange.min;
                    pdMax.value = this.pdAvailableRange.max;
                    this.updateRangeValues('pd');
                }
                
                if (owMin && owMax) {
                    owMin.value = this.owAvailableRange.min;
                    owMax.value = this.owAvailableRange.max;
                    this.updateRangeValues('ow');
                }
                
                // 保存状態もクリア
                this.selectedFilters = {
                    series: [],
                    pd: [],
                    ow: []
                };
                
                // フィルターを更新（すべて表示）
                this.updateFrameFilters();
            }

            updateFrameFilters() {
                // 選択されたフィルターを取得
                const selectedSeries = this.getSelectedFilterValues('series-filters');

                // 選択状態を保存
                this.selectedFilters.series = selectedSeries;

                // フィルタリング
                this.filteredFrames = this.availableFrames.filter(frame => {
                    const filename = typeof frame === 'string' ? frame : frame.filename;
                    const parsed = this.parseFrameFilename(filename);
                    
                    if (!parsed) return false;

                    const seriesMatch = selectedSeries.length === 0 || selectedSeries.includes(parsed.series);
                    const pdMatch = parsed.pd >= this.pdRange.min && parsed.pd <= this.pdRange.max;
                    const owMatch = parsed.ow >= this.owRange.min && parsed.ow <= this.owRange.max;

                    return seriesMatch && pdMatch && owMatch;
                });

                this.renderFrameGrid();
            }

            getSelectedFilterValues(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return [];

                const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
                return Array.from(checkboxes).map(cb => cb.value);
            }

            renderFrameGrid() {
                const grid = document.getElementById('frame-grid');
                if (!grid) return;

                if (this.filteredFrames.length === 0) {
                    grid.innerHTML = '<div class="loading">条件に一致するフレームが見つかりません</div>';
                    return;
                }

                grid.innerHTML = '';
                this.filteredFrames.forEach(frame => {
                    const filename = typeof frame === 'string' ? frame : frame.filename;
                    const frameItem = this.createFrameItem(filename);
                    grid.appendChild(frameItem);
                });
            }

            createFrameItem(filename) {
                const item = document.createElement('div');
                item.className = 'frame-item';

                const img = document.createElement('img');
                img.src = `./frames/${filename}`;
                img.alt = filename;
                img.style.width = this.logicalImageWidth + 'px';
                img.style.height = this.logicalImageHeight + 'px';
                img.onerror = () => {
                    img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkVycm9yPC90ZXh0Pgo8L3N2Zz4K';
                };

                const name = document.createElement('div');
                name.className = 'frame-item-name';
                name.textContent = this.filenameToDisplayName(filename);

                item.appendChild(img);
                item.appendChild(name);

                item.addEventListener('click', () => this.selectFrame(filename));

                return item;
            }

            // フレームサイズを判定する機能
            getFrameSize(frameImage) {
                const width = frameImage.width;
                const height = frameImage.height;
                
                if (width === 1210 && height === 454) {
                    return 'large';  // 新しい大きいサイズ
                } else if (width === 605 && height === 227) {
                    return 'standard';  // 現在の標準サイズ
                } else {
                    console.warn(`予期しないフレームサイズ: ${width}×${height}`);
                    return 'unknown';
                }
            }

            async selectFrame(filename) {
                try {
                    this.frameImageName = filename;
                    
                    const img = new Image();
                    img.onload = () => {
                        this.originalFrameImage = img;
                        this.originalFrameSize = {
                            width: img.width,
                            height: img.height
                        };
                        
                        // フレームサイズタイプを判定・保存
                        this.frameType = this.getFrameSize(img);
                        console.log(`フレームサイズタイプ: ${this.frameType} (${img.width}×${img.height})`);
                        
                        // 現在のテクスチャ状態に応じて処理
                        if (this.currentTexture === null) {
                            // テクスチャなし - カラー設定を適用
                            this.applyColorAndResize();
                        } else {
                            // テクスチャあり - テクスチャ処理を適用
                            this.applyTextureAndResize();
                        }
                        this.redraw();
                        this.updateStatusBar();
                        this.updateInfoWindowContent();
                        this.updateProductName();
                        this.saveSettings();
                        this.closeFrameSelector();
                    };
                    
                    img.onerror = () => {
                        console.error('フレーム画像の読み込みに失敗:', filename);
                    };
                    
                    img.src = `./frames/${filename}`;
                } catch (error) {
                    console.error('フレーム選択エラー:', error);
                }
            }

            // テクスチャ選択関連の機能
            toggleTextureWindow() {
                this.textureWindowVisible = !this.textureWindowVisible;
                const window = document.getElementById('texture-window');
                
                if (this.textureWindowVisible) {
                    window.classList.add('show');
                    if (this.availableTextures.length === 0) {
                        this.loadTextureList().then(() => {
                            this.renderTextureGrid();
                        });
                    } else {
                        this.renderTextureGrid();
                    }
                } else {
                    window.classList.remove('show');
                }
            }

            async loadTextureList() {
                try {
                    const response = await fetch('./textures/texture-list.json', {
                        cache: 'no-cache'
                    });
                    if (!response.ok) {
                        console.log('texture-list.jsonが見つかりません。デフォルトテクスチャを使用します。');
                        this.availableTextures = this.getDefaultTextures();
                        return;
                    }
                    const data = await response.json();
                    
                    // ファイル名のみの配列に対応
                    if (Array.isArray(data)) {
                        // シンプルな配列形式 ["file1.png", "file2.png"]
                        this.availableTextures = data.map(filename => ({
                            name: this.filenameToDisplayName(filename),
                            type: 'image',
                            file: filename
                        }));
                    } else if (data.textures && Array.isArray(data.textures)) {
                        // オブジェクト形式との互換性 {"textures": ["file1.png", "file2.png"]}
                        const textureArray = data.textures;
                        this.availableTextures = textureArray.map(item => {
                            if (typeof item === 'string') {
                                // ファイル名のみの場合
                                return {
                                    name: this.filenameToDisplayName(item),
                                    type: 'image',
                                    file: item
                                };
                            } else {
                                // オブジェクト形式の場合（従来互換）
                                return item;
                            }
                        });
                    } else {
                        // 予期しない形式
                        console.log('texture-list.jsonの形式が不正です。デフォルトテクスチャを使用します。');
                        this.availableTextures = this.getDefaultTextures();
                        return;
                    }
                    
                    console.log(`${this.availableTextures.length}個のテクスチャを読み込みました`);
                } catch (error) {
                    console.log('外部テクスチャの読み込みに失敗。デフォルトテクスチャを使用します:', error);
                    this.availableTextures = this.getDefaultTextures();
                }
            }

            filenameToDisplayName(filename) {
                // ファイル名から表示名を生成（バージョン情報除去対応）
                return filename
                    .replace(/\.[^/.]+$/, '')      // 拡張子を削除
                    .replace(/_v[\d\.]+/g, '')     // バージョン削除 (_v1.2, _v2.0.1等)
                    .replace(/_\d{8}/g, '')        // 日付削除 (_20231201等)
                    .replace(/_build\d+/g, '')     // ビルド番号削除 (_build001等)
                    .replace(/_rev\d+/g, '')       // リビジョン削除 (_rev3等)
                    .replace(/_/g, ' ')            // アンダースコアをスペースに
                    .replace(/\b\w/g, l => l.toUpperCase()); // 各単語の最初を大文字に
            }

            getDefaultTextures() {
                // デフォルトテクスチャなし（外部ファイルのみ）
                return [];
            }

            renderTextureGrid() {
                const grid = document.getElementById('texture-grid');
                if (!grid) return;

                // 「なし」オプションを保持
                const noneOption = grid.querySelector('.texture-item');
                grid.innerHTML = '';
                grid.appendChild(noneOption);
                
                // 現在の選択を更新
                const textureItems = grid.querySelectorAll('.texture-item');
                textureItems.forEach(item => item.classList.remove('selected'));
                if (this.currentTextureName === 'none') {
                    noneOption.classList.add('selected');
                }

                if (this.availableTextures.length === 0) {
                    // テクスチャがない場合のメッセージ
                    const noTextureMsg = document.createElement('div');
                    noTextureMsg.className = 'loading';
                    noTextureMsg.textContent = 'テクスチャファイルが見つかりません。./textures/フォルダにテクスチャ画像とtexture-list.jsonを配置してください。';
                    grid.appendChild(noTextureMsg);
                } else {
                    this.availableTextures.forEach(texture => {
                        const textureItem = this.createTextureItem(texture);
                        grid.appendChild(textureItem);
                    });
                }
            }

            createTextureItem(texture) {
                const item = document.createElement('div');
                item.className = 'texture-item';
                if (this.currentTextureName === texture.name) {
                    item.classList.add('selected');
                }

                const preview = document.createElement('div');
                preview.className = 'texture-preview';

                if (texture.type === 'pattern') {
                    const patternStyle = this.getPatternStyle(texture.pattern);
                    preview.style.background = patternStyle;
                } else if (texture.type === 'color') {
                    preview.style.background = texture.color;
                } else if (texture.type === 'image' && texture.file) {
                    preview.style.backgroundImage = `url(./textures/${texture.file})`;
                }

                const name = document.createElement('div');
                name.className = 'texture-item-name';
                name.textContent = texture.name;

                item.appendChild(preview);
                item.appendChild(name);

                item.addEventListener('click', () => this.selectTexture(texture.name, texture));

                return item;
            }

            getPatternStyle(pattern) {
                switch (pattern) {
                    case 'wood1':
                        return 'linear-gradient(45deg, #8B4513 25%, #A0522D 25%, #A0522D 50%, #8B4513 50%, #8B4513 75%, #A0522D 75%), linear-gradient(-45deg, #654321 25%, #8B4513 25%, #8B4513 50%, #654321 50%, #654321 75%, #8B4513 75%)';
                    case 'wood2':
                        return 'linear-gradient(90deg, #DEB887 0%, #CD853F 30%, #8B7355 60%, #DEB887 100%)';
                    case 'metal':
                        return 'linear-gradient(45deg, #C0C0C0 25%, #A8A8A8 25%, #A8A8A8 50%, #C0C0C0 50%, #C0C0C0 75%, #A8A8A8 75%), linear-gradient(-45deg, #E5E5E5 25%, #C0C0C0 25%, #C0C0C0 50%, #E5E5E5 50%, #E5E5E5 75%, #C0C0C0 75%)';
                    case 'leather':
                        return 'radial-gradient(circle at 20% 20%, #8B4513 0%, #654321 40%, #8B4513 100%)';
                    default:
                        return '#cccccc';
                }
            }

            async selectTexture(textureName, textureData = null) {
                try {
                    this.currentTextureName = textureName;
                    
                    if (textureName === 'none') {
                        this.currentTexture = null;
                        // 即座に反映
                        this.applyTextureToFrame();
                        this.renderTextureGrid();
                        this.saveSettings();
                    } else if (textureData) {
                        if (textureData.type === 'image' && textureData.file) {
                            // 外部画像ファイルを読み込み（605×227固定サイズ）
                            const img = new Image();
                            img.onload = () => {
                                // 画像が605×227でない場合は警告
                                if (img.width !== 605 || img.height !== 227) {
                                    console.warn(`テクスチャ画像 ${textureData.file} のサイズが ${img.width}×${img.height} です。推奨サイズは605×227です。`);
                                }
                                this.currentTexture = img;
                                // 即座に反映
                                this.applyTextureToFrame();
                                this.renderTextureGrid();
                                this.saveSettings();
                            };
                            img.onerror = () => {
                                console.error('テクスチャ画像の読み込みに失敗:', textureData.file);
                            };
                            img.src = `./textures/${textureData.file}`;
                            return; // 非同期処理のためここで返る
                        } else {
                            // パターンまたは色
                            this.currentTexture = textureData;
                            // 即座に反映
                            this.applyTextureToFrame();
                            this.renderTextureGrid();
                            this.saveSettings();
                        }
                    }
                } catch (error) {
                    console.error('テクスチャ選択エラー:', error);
                }
            }

            applyTextureToFrame() {
                if (!this.originalFrameImage) return;

                if (this.currentTexture === null) {
                    // テクスチャなし - 既存のカラー設定を使用
                    this.applyColorAndResize();
                } else {
                    // テクスチャありの場合
                    this.applyTextureAndResize();
                }
                
                this.redraw();
                this.updateStatusBar();
                this.updateInfoWindowContent();
            }

            applyTextureAndResize() {
                if (!this.originalFrameImage) return;

                // キャンバス作成（元画像と同サイズ）
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = this.originalFrameImage.width;
                canvas.height = this.originalFrameImage.height;

                // 元画像を描画
                ctx.drawImage(this.originalFrameImage, 0, 0);

                // 画像データを取得
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // 白色用のカラー設定を計算（既存のサブカラー設定を使用）
                const subRgb = this.hsvToRgb(this.subHue / 360, this.subSaturation / 100, this.subBrightness / 100);
                const subR = Math.round(subRgb.r * 255);
                const subG = Math.round(subRgb.g * 255);
                const subB = Math.round(subRgb.b * 255);
                const subAlpha = this.subOpacity / 100;

                // テクスチャが画像の場合の前処理
                let textureImageData = null;
                if (this.currentTexture instanceof Image) {
                    // テクスチャサイズを元のフレーム画像サイズに合わせる
                    let textureWidth = this.originalFrameImage.width;
                    let textureHeight = this.originalFrameImage.height;
                    console.log(`テクスチャサイズをフレーム画像に合わせる: ${textureWidth}×${textureHeight}`);
                    
                    // テクスチャ画像データを取得
                    const texCanvas = document.createElement('canvas');
                    const texCtx = texCanvas.getContext('2d');
                    texCanvas.width = textureWidth;
                    texCanvas.height = textureHeight;
                    
                    // テクスチャを指定サイズに描画（リサイズ）
                    texCtx.drawImage(this.currentTexture, 0, 0, textureWidth, textureHeight);
                    textureImageData = texCtx.getImageData(0, 0, textureWidth, textureHeight);
                }

                // ピクセル処理（最適化版）
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];
                    const sum = r + g + b;
                    
                    // 透明部分はスキップ
                    if (a === 0) continue;
                    
                    // 黒っぽい部分（閾値以下）を判定
                    if (sum < 60) {
                        // 黒部分 - テクスチャを適用
                        if (this.currentTexture.type === 'color') {
                            // 単色の場合（最速）
                            const color = this.hexToRgb(this.currentTexture.color);
                            data[i] = color.r;
                            data[i + 1] = color.g;
                            data[i + 2] = color.b;
                        } else if (this.currentTexture.type === 'pattern') {
                            // パターンの場合
                            const pixelIndex = Math.floor(i / 4);
                            const x = pixelIndex % canvas.width;
                            const y = Math.floor(pixelIndex / canvas.width);
                            const patternColor = this.getPatternColor(this.currentTexture.pattern, x, y);
                            data[i] = patternColor.r;
                            data[i + 1] = patternColor.g;
                            data[i + 2] = patternColor.b;
                        } else if (textureImageData) {
                            // 画像テクスチャの場合（フレームサイズに応じて適応）
                            const pixelIndex = Math.floor(i / 4);
                            const x = pixelIndex % canvas.width;
                            const y = Math.floor(pixelIndex / canvas.width);
                            
                            // テクスチャサイズを取得（元のフレーム画像サイズ）
                            const texWidth = this.originalFrameImage.width;
                            const texHeight = this.originalFrameImage.height;
                            
                            // フレーム画像の座標をテクスチャ座標に変換（同じ比率なので直接マッピング）
                            const texX = Math.floor(x);
                            const texY = Math.floor(y);
                            
                            // テクスチャ画像内の座標に収める
                            const clampedTexX = Math.max(0, Math.min(texWidth - 1, texX));
                            const clampedTexY = Math.max(0, Math.min(texHeight - 1, texY));
                            
                            // テクスチャピクセルを取得
                            const texIndex = (clampedTexY * texWidth + clampedTexX) * 4;
                            const texR = textureImageData.data[texIndex];
                            const texG = textureImageData.data[texIndex + 1];
                            const texB = textureImageData.data[texIndex + 2];
                            const texA = textureImageData.data[texIndex + 3];
                            
                            // 黒部分を完全にテクスチャで置き換え
                            data[i] = texR;
                            data[i + 1] = texG;
                            data[i + 2] = texB;
                            data[i + 3] = texA; // テクスチャのアルファ値をそのまま使用
                        }
                    } 
                    // 白っぽい部分（カラー設定のサブカラーを適用）
                    else if (sum > 700) {
                        data[i] = subR;
                        data[i + 1] = subG;
                        data[i + 2] = subB;
                        data[i + 3] = Math.round(255 * subAlpha);
                    }
                }

                // 変更された画像データを適用
                ctx.putImageData(imageData, 0, 0);
                
                // 新しい画像として設定
                const newImg = new Image();
                newImg.onload = () => {
                    this.frameImage = newImg;
                    this.frameImageData = imageData;
                    
                    // サイズ調整
                    if (this.scaleRatio > 0) {
                        const targetWidth = this.frameRealSize * this.scaleRatio;
                        this.frameSize.width = targetWidth;
                        this.frameSize.height = (this.originalFrameSize.height / this.originalFrameSize.width) * targetWidth;
                    } else {
                        this.frameSize.width = this.originalFrameSize.width;
                        this.frameSize.height = this.originalFrameSize.height;
                    }
                    
                    // 即座に再描画
                    this.redraw();
                };
                newImg.src = canvas.toDataURL();
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            getPatternColor(pattern, x, y) {
                switch (pattern) {
                    case 'wood1':
                        const wave = Math.sin(y * 0.1) * 20;
                        return (x + wave) % 40 < 20 ? {r: 139, g: 69, b: 19} : {r: 160, g: 82, b: 45};
                    case 'wood2':
                        const grain = Math.sin(y * 0.05) * 30;
                        return (x + grain) % 60 < 30 ? {r: 222, g: 184, b: 135} : {r: 205, g: 133, b: 63};
                    case 'metal':
                        return (x + y) % 4 < 2 ? {r: 192, g: 192, b: 192} : {r: 169, g: 169, b: 169};
                    case 'leather':
                        const noise = (Math.sin(x * 0.3) + Math.cos(y * 0.3)) * 20;
                        return {r: 139 + noise, g: 69 + noise/2, b: 19 + noise/4};
                    default:
                        return {r: 128, g: 128, b: 128};
                }
            }

            // ウィンドウ位置保存関連の機能
            saveWindowPosition(windowId) {
                const windowElement = document.getElementById(windowId);
                if (!windowElement) {
                    console.warn(`ウィンドウが見つかりません: ${windowId}`);
                    return;
                }

                // 現在のtransform値を取得
                const style = window.getComputedStyle(windowElement);
                const transform = style.transform;
                
                let x = 0, y = 0;
                
                if (transform && transform !== 'none') {
                    const match = transform.match(/matrix\([\d\.\-\s,]+,\s*([\d\.\-]+),\s*([\d\.\-]+)\)/);
                    if (match) {
                        // matrix形式の場合
                        x = parseFloat(match[1]);
                        y = parseFloat(match[2]);
                    } else {
                        // translate形式の場合
                        const translateMatch = transform.match(/translate\(([\d\.\-]+)px,\s*([\d\.\-]+)px\)/);
                        if (translateMatch) {
                            x = parseFloat(translateMatch[1]);
                            y = parseFloat(translateMatch[2]);
                        }
                    }
                } else {
                    // transformがない場合は0,0として保存（CSS初期位置を使用）
                    x = 0;
                    y = 0;
                }

                this.windowPositions[windowId] = { x, y };
                console.log(`ウィンドウ位置を保存: ${windowId} -> (${x}, ${y})`);
                
                // 設定を保存
                this.saveSettings();
            }

            restoreWindowPositions() {
                // 保存された位置を復元、または初期位置にリセット
                Object.keys(this.windowPositions).forEach(windowId => {
                    const windowElement = document.getElementById(windowId);
                    if (windowElement && this.windowPositions[windowId]) {
                        const pos = this.windowPositions[windowId];
                        // 保存された位置を復元（transformを使用）
                        windowElement.style.left = '';
                        windowElement.style.top = '';
                        windowElement.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
                        console.log(`位置復元: ${windowId} -> (${pos.x}, ${pos.y})`);
                    }
                });
                
                // 保存された位置がない場合はCSSデフォルト位置をそのまま使用
                // （CSSでcalc()で中央配置済み）
            }

            // 全リセット機能
            resetAll() {
                console.log('アプリを初期状態にリセットします...');
                
                // 画像をクリア
                this.baseImage = null;
                this.frameImage = null;
                this.originalFrameImage = null;
                this.frameImageData = null;
                this.baseImageName = '';
                this.frameImageName = '';
                
                // 測定データをクリア
                this.measurementPoints = [];
                this.pixelDistance = 0;
                this.realDistance = 0;
                this.scaleRatio = 0;
                this.draggingPointIndex = -1;
                
                // 設定を初期値に戻す
                this.baseRealSize = 60;
                this.frameRealSize = 160;
                this.frameOffset = {x: 100, y: 100};
                this.frameSize = {width: 0, height: 0};
                this.originalFrameSize = {width: 0, height: 0};
                
                // カラー設定を初期値に戻す
                this.hue = 0;
                this.saturation = 100;
                this.brightness = 0;
                this.opacity = 100;
                this.subHue = 0;
                this.subSaturation = 0;
                this.subBrightness = 0;
                this.subOpacity = 0;
                
                // ウィンドウ位置をクリア
                this.windowPositions = {};
                
                // テクスチャをリセット
                this.currentTexture = null;
                this.currentTextureName = 'none';
                
                // UI状態をリセット
                this.colorWindowVisible = false;
                this.infoWindowVisible = false;
                this.textureWindowVisible = false;
                this.currentColorTab = 'black';
                this.mode = 'measure';
                
                // ウィンドウを閉じる
                const colorWindow = document.getElementById('color-window');
                if (colorWindow) colorWindow.classList.remove('show');
                
                const infoWindow = document.getElementById('info-window');
                if (infoWindow) infoWindow.classList.remove('show');
                
                const textureWindow = document.getElementById('texture-window');
                if (textureWindow) textureWindow.classList.remove('show');
                
                const frameModal = document.getElementById('frame-selector-modal');
                if (frameModal) frameModal.style.display = 'none';
                
                // ファイル入力をクリア
                if (this.faceInput) this.faceInput.value = '';
                if (this.frameInput) this.frameInput.value = '';
                
                // LocalStorageをクリア
                localStorage.removeItem('faceMeasurementSettings');
                
                // ウィンドウ位置を初期値に戻す（transformをクリア）
                ['magnifier', 'info-window', 'color-window'].forEach(windowId => {
                    const windowElement = document.getElementById(windowId);
                    if (windowElement) {
                        windowElement.style.transform = '';
                        console.log(`ウィンドウ位置をリセット: ${windowId}`);
                    }
                });
                
                // UIを更新
                this.applySettingsToUI();
                this.updateModeButton();
                this.updateStatusBar();
                this.updateInfoWindowContent();
                this.redraw();
                
                console.log('リセット完了');
            }
        }

        // ウィンドウドラッグ機能
        function makeDraggable(windowElement) {
            const dragBar = windowElement.querySelector('.window-drag-bar');
            if (!dragBar) return;
            
            let isDragging = false;
            let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

            // マウスイベント
            dragBar.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            
            // タッチイベント
            dragBar.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                dragStart({clientX: touch.clientX, clientY: touch.clientY});
            }, {passive: false});
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    drag({clientX: touch.clientX, clientY: touch.clientY});
                }
            }, {passive: false});
            
            document.addEventListener('touchend', dragEnd);

            function dragStart(e) {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                isDragging = true;
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault && e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    setTranslate(currentX, currentY, windowElement);
                }
            }

            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                
                // ウィンドウ位置を保存
                if (app && windowElement.id) {
                    app.saveWindowPosition(windowElement.id);
                }
            }

            function setTranslate(xPos, yPos, el) {
                el.style.transform = `translate(${xPos}px, ${yPos}px)`;
            }
        }

        // アプリ初期化
        let app;
        
        document.addEventListener('DOMContentLoaded', () => {
            app = new FaceMeasurementApp();
            
            // ウィンドウをドラッグ可能にする
            makeDraggable(document.getElementById('color-window'));
            makeDraggable(document.getElementById('info-window'));
            makeDraggable(document.getElementById('texture-window'));
            
            // 拡大鏡をドラッグ可能にする
            makeDraggableMagnifier(document.getElementById('magnifier'));
        });
        
        // 拡大鏡専用のドラッグ機能（ドラッグバーのみ）
        function makeDraggableMagnifier(magnifierElement) {
            const dragBar = magnifierElement.querySelector('.magnifier-drag-bar');
            if (!dragBar) return;
            
            let isDragging = false;
            let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

            // マウスイベント
            dragBar.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            
            // タッチイベント
            dragBar.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                dragStart({clientX: touch.clientX, clientY: touch.clientY});
            }, {passive: false});
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    drag({clientX: touch.clientX, clientY: touch.clientY});
                }
            }, {passive: false});
            
            document.addEventListener('touchend', dragEnd);

            function dragStart(e) {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                isDragging = true;
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault && e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    setTranslate(currentX, currentY, magnifierElement);
                }
            }

            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                
                // 拡大鏡の位置を保存
                if (app && magnifierElement.id) {
                    app.saveWindowPosition(magnifierElement.id);
                }
            }

            function setTranslate(xPos, yPos, el) {
                el.style.transform = `translate(${xPos}px, ${yPos}px)`;
            }
        }
    </script>
</body>
</html>
